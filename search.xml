<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java 系列（一） 动态代理（下）]]></title>
    <url>%2F2017%2F07%2F18%2Fdongtaidaili3%2F</url>
    <content type="text"><![CDATA[前两章想必大家都知道动态代理是怎么回事，本小节的内容是动态代理的实践操作了。在Android项目中如何实现按钮的防双击（防抖动）。这个在Android上又叫Hook技术 1.前言对于一些特定需求使用也是非常无可奈何的，比如Android里面对所有的点击事件进行一定的操作，比如防双击（防抖动），插桩等。对于这种需求的解决方案肯定不止一个了，现在通用的（大众的）解决方案有六个： 1、每个调用的时候处理，点击第一下之后将按钮不可点击状态，轮询一定时间之后变为可点击状态（代码不贴了，估计没人会这么写）2、写一个工具类，返回布尔型，在里面计算点击周期等，（同样不建议）3、复写view.onClickeListener,重新定义一个抽象类，承接OnClickListener的事件，在进行处理完之后分发， public abstract class NoDoubleClickListener implements View.OnClickListener { private int MIN_CLICK_DELAY_TIME = 500; private long lastClickTime = 0; public abstract void onNoDoubleClick(View v); @Override public void onClick(View v) { long currentTime = Calendar.getInstance().getTimeInMillis(); if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) { lastClickTime = currentTime; onNoDoubleClick(v); } } } 4、RxBinding操作，或者RXJava自己封装 通过学习RXJava可知有一个操作符throttleFirst ,作用是在一定时间内的时间，只发送第一条事件，和debounce,作用是在一定时间没有变化才会发送事件。 所以可以使用RxBinding： RxView.clickEvents(button) .throttleFirst(500, TimeUnit.MILLISECONDS) .subscribe(clickAction); 看起来是不是很简单，但是要导入Rxjava相关的框架，还会破坏butterknife的结构，小伙伴可以想想怎么写。 5、使用装饰器模式 理论上可以实现，但没有写过，小伙伴可以试试。6、动态代理 本节内容的重头戏，在下部分详细概述怎么写的。 2.动态代理实现仿双击 #确定需求我们的具体需求是什么，android上的动态代理的形式和Java有什么不同，虽然Android程序是用java编写的（原生）。 首次Android中的Activity是有生命周期的，所以要在所有使用的地方注册 找到所要插入的点 每次使用SetOnClickListener的方法，在View的方法里面 都会使用ListenerInfo这个类，下面看看这个类 所以我们按图索骥，一步一步的找到真正实现的接口的地方，就是在ListenerInfo的OnClickListener。对于这个类我们也可以看出，所有的触摸事件（包括滑动，长按，按键等）都是在这个位置进行监听的。下面我们来写动态代理的代码： Class viewClass = Class.forName(&quot;android.view.View&quot;); Method method = viewClass.getDeclaredMethod(&quot;getListenerInfo&quot;); method.setAccessible(true); Object listenerInfoInstance = method.invoke(view); //hook信息载体实例listenerInfo的属性 Class listenerInfoClass = Class.forName(&quot;android.view.View$ListenerInfo&quot;); Field onClickListerField = listenerInfoClass.getDeclaredField(&quot;mOnClickListener&quot;); onClickListerField.setAccessible(true); View.OnClickListener onClickListerObj = (View.OnClickListener) onClickListerField.get(listenerInfoInstance);//获取已设置过的监听器 if (isScrollAbsListview &amp;&amp; onClickListerObj instanceof OnClickListenerProxy) {//针对adapterView的滚动item复用会导致重复hook代理监听器 return; } //hook事件，设置自定义的载体事件监听器 onClickListerField.set(listenerInfoInstance, new OnClickListenerProxy(onClickListerObj, proxyListenerConfigBuilder.getOnClickProxyListener())); setHookedTag(view, R.id.tag_onclick); 其中OnClickListenerProxy就是我们要实现的对象，在这里要注意给view设置一个Tag,否则会出现重复代理的情况。下面我们来看看这个代理对象的实现（其实很简单的）： public class OnClickListenerProxy implements View.OnClickListener { private static final String TAG = &quot;OnClickListenerProxy&quot;; private View.OnClickListener onClickListener; private int MIN_CLICK_DELAY_TIME = 1000; private long lastClickTime = 0; private OnListenerProxyCallBack.OnClickProxyListener onClickProxyListener; public OnClickListenerProxy(View.OnClickListener onClickListener, OnListenerProxyCallBack .OnClickProxyListener onClickProxyListener) { this.onClickListener = onClickListener; this.onClickProxyListener = onClickProxyListener; } @Override public void onClick(final View v) { long currentTime = Calendar.getInstance().getTimeInMillis(); //System.out.println(&quot;--------------&quot; + (currentTime - lastClickTime) + &quot;--------------&quot;); if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) { lastClickTime = currentTime; // Log.e(&quot;OnClickListenerProxy&quot;, &quot;OnClickListenerProxy&quot;+v.getTag()); Context context = v.getContext(); if (context instanceof Activity) { // Log.e(&quot;OnClickListenerProxy&quot;, context.getClass().getSimpleName()); } if (null != onClickProxyListener) {//点击代理回调 onClickProxyListener.onClickProxy(v); } if (null != onClickListener) { onClickListener.onClick(v); } } } } 通过Context可以判断Activity的，和获取Activity的具体名称，对于插桩是方便的。同理我们可以实现对于长按事件的监听，甚至于对Listview的Item的点击事件，Recyclerview的Item的点击事件。下面我们来看看Hook的代理的入口： public void hookStart(Activity activity) { if (null != activity) { View view = activity.getWindow().getDecorView(); if (null != view) { if (view instanceof ViewGroup) { hookStart((ViewGroup) view); } else { hookOnClickListener(view, false); hookOnLongClickListener(view, false); } } } } 这只是一种很简单的情况，但如果像列表控件带滚动的形式，又是另一种处理方式，这是因为Android内部的缓存机制导致的这样的问题。 public void hookStart(ViewGroup viewGroup, boolean isScrollAbsListview) { if (viewGroup == null) { return; } int count = viewGroup.getChildCount(); for (int i = 0; i &lt; count; i++) { View view = viewGroup.getChildAt(i); if (view instanceof ViewGroup) {//递归查询所有子view // 若是布局控件（LinearLayout或RelativeLayout）,继续查询子View hookStart((ViewGroup) view, isScrollAbsListview); } else { hookOnClickListener(view, isScrollAbsListview); hookOnLongClickListener(view, isScrollAbsListview); } } hookOnClickListener(viewGroup, isScrollAbsListview); hookOnLongClickListener(viewGroup, isScrollAbsListview); hookListViewListener(viewGroup); } 必须到递归获取到所有的view控件才可以继续向下运行。 对于在基类里面调用代理呢，肯定是要在view绘制完全的时候， private boolean isHookListener = false; @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); if (isHookListener) {//防止退出的时候还hook return; } getWindow().getDecorView().post(new Runnable() { @Override public void run() {//等待view都执行完毕之后再hook,否则onLayoutChange执行多次就会hook多次 HookViewManager.getInstance().hookStart((Activity) mContext); isHookListener = true; } }); } 直到这一步才正式的代理了view的相关事件的监听。 3.结束语会思考的童鞋会由此思考Hook技术是怎么回事？ 1.Hook英文翻译为“钩子”，而钩子就是在事件传送到终点前截获并监控事件的传输，像个钩子钩上事件一样，并且能够在钩上事件时，处理一些自己特定的事件；2.Hook使它能够将自己的代码“融入”被勾住（Hook）的进程中，成为目标进程的一部分；3.在Andorid沙箱机制下，Hook是我们能通过一个程序改变其他程序某些行为得以实现； 第一条是不是很熟悉，其实在java层面大部分的Hook都是通过代理实现的，但Hook技术不止包括java层面，还有Native层面，也就是C/C++层面，Android中著名的Hook框架就是——Xposed平台。Hook技术的成功很广泛，只要你像在Android手机上做点黑科技，Hook技术是你必不可少的知识点，包括现在著名的插件化浪潮，也是在其基础上引申拓展的。动态代理三部分讲完了，下节将开始我们新的学习。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 系列（一） 动态代理（上）]]></title>
    <url>%2F2017%2F07%2F18%2Fdongtaidaili1%2F</url>
    <content type="text"><![CDATA[想必大家都很耳熟这个模式，或者说这个思想，但实际在项目中用的并不是很多，这节课程我们来详细描述-动态代理是怎么一回事，和使用的范围，以及一定程度的扩展，在Android中的简单实现。 动态代理的介绍1.什么是动态代理 定义：为其他对象提供一种代理以控制对这个对象的访问请注意这个控制，仅代表在这个对象处理之前或之后做某些操作，并不会对这个对象做什么操作，也不会影响这个事务的运行。其中动态代理只是代理模式的一种，代理模式还包括静态代理等。 优缺点：可以实现对于委托类的隐藏，可以对于统一的操作节约代码，实现解耦，但jdk中的proxy只能实现对接口的代理，如果想代理其他的方法等，需要用到第三方的sdk. 使用典范：spring的AOP模式，日志系统，缓存系统等。 例图： 1，代理模式 2，动态代理模式 我的看法动态代理模式存在的必要：我们在写主业务流程时，经常会遇到一些细枝末节的东西要处理，比如缓存，写日志等，但如果将其直接放在主题代码中，这是对OO的破坏，也会影响整体业务流程的浏览，另一方面会做很多无用功，有人会说：把这种代码抽出来，放在一个基类里面。当然这不失为一种解决方案，但会造成主体代码和枝节代码的耦合加深，会使在模块中依旧添加其他的依赖，而且对于代码移植比较繁琐。所以我们使用动态代理这种思想，降低了代码的耦合程度，也更好的隐藏枝节代码，和保护主体代码。看到这里有人会很疑惑，动态代理怎么和装饰器模式这么类似，我们将会在下节将装饰器模式和动态代理的不同，以及两者的之间的互补。 2.动态代理的实现 下面来看一下代码演示（没有使用《Java编程思想》和《设计模式之禅》的代码，详情请参考这两本书） 1，接口 public interface Subject { public void rent(); public void hello(String str); } 2，实现类，这个类就是我们的真实对象 public class RealSubject implements Subject { @Override public void rent() { System.out.println(&quot;I want to rent my house&quot;); } @Override public void hello(String str) { System.out.println(&quot;hello: &quot; + str); } } 3，要代理的方法 public class DynamicProxy implements InvocationHandler { // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) { this.subject = subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 在代理真实对象前我们可以添加一些自己的操作 System.out.println(&quot;before rent house&quot;); // 真实的方法 System.out.println(&quot;Method:&quot; + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println(&quot;after rent house&quot;); return null; } } 4，Client方法 public class Client { public static void main(String[] args) { // 我们要代理的真实对象 Subject realSubject = new RealSubject(); // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello(&quot;world&quot;); } } 5,总结 动态代理的步骤总结:1,定义一个接口，并实现这个接口的类，就是实现类，或者称为委托类2，定义一个代理类，实现jdk的InvocationHandler接口（这个接口在java.lang.reflect包里面，想必大家可以猜到内部怎么实现的吧），主要是将运行时的任务和你准备处理的操作进行搭配。3,生成代理对象，调用Proxy的方法进行调用，使用。 #3. 结束语 简单的动态代理的代码就是这么多，下节将装饰器模式和动态代理的搭配，通过简单的代码模拟，大家是不是对动态代理已经有所认识，赶快行动起来吧。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 系列（一） 动态代理（中）]]></title>
    <url>%2F2017%2F07%2F18%2Fdongtaidaili2%2F</url>
    <content type="text"><![CDATA[从上节的学习想必大家都知道动态代理怎么写了，现在我们拓展一些，动态代理和装饰器模式，想必大家都很困惑。本小节主要介绍动态代理和装饰器模式的不同以及如何相互搭配。 1.动态代理和装饰器模式 1.装饰器模式的介绍： 装饰器模式能够实现保持原有的接口，并为新的接口动态的添加功能。装饰器实现了java编程上的一个准则，多组合，少继承。 装饰器的一个典型的例子是：java中的IO流的实现,大家在转过头来看javaIO流的思维导图，想必会恍然大悟了。 例图： （ps:这个图会和我们下面将要讲的装饰器模式+动态代理的UML图一致，不再重复显示） 2.两者区别 两者都可以在保持主业务流程下，对对象进行添加方法，增强这个类的使用。 但两者有着一些区别： 装饰器模式继承了接口，添加了新类，而代理没有对原代码有任何操作。 装饰器中的继承和创建新类，会造成出现大量的包装类，对于代码阅读是有困难的。 2.动态代理的装饰器模式搭配为什么要这样搭配呢，想必大家在实践过程中使用代理都会遇到的问题–动态代理的扩展性。动态代理是没有办法在源代理类上直接进行拓展的（否则的话全部的接口都会实现拓展的对象），但对于我们来说，并不需要，只是对某些委托类进行操作，这就不太这么方便操作了。所以这时候使用装饰器模式比较好的搭配使用，添加自定义的扩展。相对于简单的动态代理，这时候要增加几个新的方法：提供动态代理实例的静态工厂类（ProxyFactory）和抽象装饰器（Decorator） 首次我们看抽象主题接口 public interface AbstractSubject { void request(); } 真实主题类（委托类/被代理的对象） public class RealSubject implements AbstractSubject { public void request() { System.out.println(&quot;真实的方法-----RealSubject&apos;s request() ...&quot;); } } 抽象装饰器类（一定要以自己的父类、父接口为一个属性） public class Decorator implements AbstractSubject { protected AbstractSubject subject = null; public Decorator(AbstractSubject subject) { this.subject = subject; } @Override public void request() { } } 具体装饰器1（根据实际情况，我这里只写三个） public class ConcreteDecorator01 extends Decorator { public ConcreteDecorator01(AbstractSubject subject) { super(subject); //调用父类装饰类的构造器 } /** * 覆盖继承树上的接口中的request()方法，用于装饰原对象 */ public void request() { System.out.println(&quot;第一层装饰 ... 装饰在原主题之前&quot;); super.subject.request(); } } 具体装饰器2（根据实际情况，我这里只写三个） public class ConcreteDecorator02 extends Decorator { public ConcreteDecorator02(AbstractSubject subject) { super(subject); //调用父类装饰类的构造器 } /** * 覆盖继承树上的接口中的request()方法，用于装饰原对象 */ public void request() { super.subject.request(); System.out.println(&quot;第二层装饰 ... 装饰在原主题之后&quot;); } } 具体装饰器3（根据实际情况，我这里只写三个） public class ConcreteDecorator03 extends Decorator { public ConcreteDecorator03(AbstractSubject subject) { super(subject); //调用父类装饰类的构造器 } /** * 覆盖继承树上的接口中的request()方法，用于装饰原对象 */ public void request() { super.subject.request(); System.out.println(&quot;第三层装饰 ... 装饰在原主题之后&quot;); } } 提供动态代理实例的静态工厂类（管理代理实现） public class ProxyFactory { /** * @param realSubject ：指定需要代理的真实主题类的实例 * @return proxy ：代理的实例 */ public static AbstractSubject getProxy(AbstractSubject realSubject) { // 获得被代理类的类加载器，使得JVM能够加载并找到被代理类的内部结构，以及已实现的interface ClassLoader loader = realSubject.getClass().getClassLoader(); // 获得被代理类已实现的所有接口interface,使得动态代理类的实例 Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces(); // 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序 InvocationHandler handler = new DynamicProxy(realSubject); /* * 使用java.lang.reflect.Proxy类中的静态方法newProxyInstance()获得代理的实例 * * loader : 被代理类的类加载器 interfaces ：被代理类已实现的所有接口，而这些是动态代理类要实现的接口列表 handler * ： 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序 * * return ：返回实现了被代理类所实现的所有接口的Object对象，即动态代理，需要强制转型 */ AbstractSubject proxy = (AbstractSubject) Proxy.newProxyInstance( loader, interfaces, handler); return proxy; } } 代理类 public class DynamicProxy implements InvocationHandler { // 被代理类的实例 Object obj = null; // 将被代理者的实例传进动态代理类的构造函数中 public DynamicProxy(Object obj) { this.obj = obj; } /** * 覆盖InvocationHandler接口中的invoke()方法 * * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到 * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊 代码切入的扩展点了。 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* * before ：doSomething(); */ System.out.println(&quot;动态代理为真实主题添加一个方法 ...&quot;); Object result = method.invoke(this.obj, args); /* * after : doSomething(); */ return result; } } client public class Client { public static void main(String[] args) { // 被代理类的实例 AbstractSubject realSubject = new RealSubject(); // 通过静态工厂获取动态代理的实例 AbstractSubject proxy = ProxyFactory.getProxy(realSubject); // 装饰之前打印出该代理实例的名称 System.out.println(&quot;装饰前：&quot; + proxy.getClass().getName()); // 装饰前使用代理实例进行原始操作 //proxy.request(); System.out.println(&quot;\n第一次装饰之后的效果如下：&quot;); proxy = new ConcreteDecorator01(proxy); System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName()); //proxy.request(); System.out.println(&quot;\n第二次装饰之后的效果如下：&quot;); proxy = new ConcreteDecorator02(proxy); System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName()); // proxy.request(); System.out.println(&quot;\n第三次装饰之后的效果如下：&quot;); proxy = new ConcreteDecorator03(proxy); System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName()); proxy.request(); } } 总结 通过上面的代码描述可以在proxy这个类已经是处理好之后的情况，在后面的大段代码都是标准的装饰器代码。 运行之后：看好我画圈的地方，下面将 AbstractSubject proxy = ProxyFactory.getProxy(realSubject); 方法去除，变成一个完整的装饰器模式，看看效果： 可以看到，结果完全相同，只有最初代理的对象不同，一个是经过代理产生的，一个是源接口。对于这样的好处毋庸置疑：代理可以放在其他模块中，对于自定义的功能添加使用装饰器自由组合，对于统一的操作放在代理对象中，这样解耦的形式比较好。 3.结束语其实设计模式之前的搭配有很多，只学单独的设计模式的概念并不是很大，很多注明的SDK都是很多设计模式相互搭配而来，请大家多多思考，下节讲动态代理的实际操作–Android中统一处理防双击/抖动。谢谢]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SharedPreferencesUtils存储对象]]></title>
    <url>%2F2017%2F07%2F16%2FSharedPreferencesUtils%2F</url>
    <content type="text"><![CDATA[SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。在我学习优化Utils工具包的一些常见的工具类。在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。 读写基本数据类型 读写Javabean类型 读写List类型 读写图片资源 1,读写基本数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * 存储基本数据类型 * @param context * @param key key * @param data value */public static void saveData(Context context, String key, Object data) &#123; String type = data.getClass().getSimpleName(); SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context .MODE_PRIVATE);//读写基本数据类型都是在一个特定的文件，以软件的包名为文件名 Editor editor = sharedPreferences.edit(); if ("Integer".equals(type)) &#123;//注意这里是integer对象，同下 editor.putInt(key, (Integer) data); &#125; else if ("Boolean".equals(type)) &#123; editor.putBoolean(key, (Boolean) data); &#125; else if ("String".equals(type)) &#123; editor.putString(key, (String) data); &#125; else if ("Float".equals(type)) &#123; editor.putFloat(key, (Float) data); &#125; else if ("Long".equals(type)) &#123; editor.putLong(key, (Long) data); &#125; editor.commit(); &#125;/** * 读取基本数据类型 * @param context * @param key key * @param defValue 当取不到值时返回默认值 * @return */ public static Object getData(Context context, String key, Object defValue) &#123; String type = defValue.getClass().getSimpleName(); SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context .MODE_PRIVATE); //defValue为为默认值，如果当前获取不到数据就返回它 if ("Integer".equals(type)) &#123; return sharedPreferences.getInt(key, (Integer) defValue); &#125; else if ("Boolean".equals(type)) &#123; return sharedPreferences.getBoolean(key, (Boolean) defValue); &#125; else if ("String".equals(type)) &#123; return sharedPreferences.getString(key, (String) defValue); &#125; else if ("Float".equals(type)) &#123; return sharedPreferences.getFloat(key, (Float) defValue); &#125; else if ("Long".equals(type)) &#123; return sharedPreferences.getLong(key, (Long) defValue); &#125; return null; &#125; 将常用到的基本数据类型存入特定的文件中，获取的时候也十分方便快捷。（PS，string不是基本数据类型） 读写Javabean类型先期准备Javabean是序列化的，需要继承Serializable接口，实现serialVersionUID。1.判断处理是否是各个数据类型 private static boolean isObject(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; !isSingle(clazz) &amp;&amp; !isArray(clazz) &amp;&amp; !isCollection(clazz) &amp;&amp; !isMap(clazz); } private static boolean isSingle(Class&lt;?&gt; clazz) { return isBoolean(clazz) || isNumber(clazz) || isString(clazz); } public static boolean isBoolean(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; (Boolean.TYPE.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz)); } public static boolean isNumber(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; (Byte.TYPE.isAssignableFrom(clazz) || Short.TYPE.isAssignableFrom(clazz) || Integer.TYPE.isAssignableFrom(clazz) || Long.TYPE.isAssignableFrom(clazz) || Float.TYPE.isAssignableFrom(clazz) || Double.TYPE.isAssignableFrom(clazz) || Number.class.isAssignableFrom(clazz)); } public static boolean isString(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; (String.class.isAssignableFrom(clazz) || Character.TYPE.isAssignableFrom(clazz) || Character.class.isAssignableFrom(clazz)); } public static boolean isArray(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; clazz.isArray(); } public static boolean isCollection(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; Collection.class.isAssignableFrom(clazz); } public static boolean isMap(Class&lt;?&gt; clazz) { return clazz != null &amp;&amp; Map.class.isAssignableFrom(clazz); } private static boolean isParcelableCreator(Field field) { return Modifier.toString(field.getModifiers()).equals(&quot;public static final&quot;) &amp;&amp; &quot;CREATOR&quot; .equals(field.getName()); } 2,插入数据 public static void setObject(Context context, Object o) { Field[] fields = o.getClass().getDeclaredFields();//获取所有声明的属性 SharedPreferences sp = context.getSharedPreferences(o.getClass().getName(), 0);//将存储的文件名改为Javabean的包名+類名 SharedPreferences.Editor editor = sp.edit(); for (int i = 0; i &lt; fields.length; ++i) { if (!isParcelableCreator(fields[i])) { Class type = fields[i].getType();//类型 class java.lang.class String name = fields[i].getName();//名称 id Object e; if (isSingle(type)) { try { if (type != Character.TYPE &amp;&amp; !type.equals(String.class)) { if (!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)) { if (type.equals(Double.TYPE)) { editor.putLong(name, Double.doubleToLongBits(fields[i] .getDouble(o)));//将double类型的数值存入 } else if (type.equals(Float.TYPE)) { editor.putFloat(name, fields[i].getFloat(o));//将float类型的数值存入 } else if (type.equals(Long.TYPE) &amp;&amp; !name.equals(&quot;serialVersionUID&quot;)) { editor.putLong(name, fields[i].getLong(o));//将long类型的数值存入 } else if (type.equals(Boolean.TYPE)) { editor.putBoolean(name, fields[i].getBoolean(o));//将boolean类型的数值存入 } } else { editor.putInt(name, fields[i].getInt(o));//将int类型的数值存入 } } else { e = fields[i].get(o);//将string类型的数值存入 editor.putString(name, null == e ? null : e.toString()); } } catch (Exception var14) { } }else if (isObject(type)) { try { e = fields[i].get(o); if (null != e) { setObject(context, e); } else { try { setObject(context, fields[i].getClass().newInstance());//重新跑一遍 } catch (InstantiationException var11) { } } } catch (Exception var12) { } } else { try { e = fields[i].get(o); //转成json插入 } catch (IllegalAccessException e1) { e1.printStackTrace(); } } } } editor.apply(); } public static &lt;T&gt; T getObject(Context context, Class&lt;T&gt; clazz) { Object o = null; try { o = clazz.newInstance(); } catch (InstantiationException e) { e.printStackTrace(); return (T) o; } catch (IllegalAccessException e) { e.printStackTrace(); return (T) o; } Field[] fields = clazz.getDeclaredFields(); SharedPreferences sp = context.getSharedPreferences(clazz.getName(), 0); for(int i = 0; i &lt; fields.length; ++i) { if(!isParcelableCreator(fields[i])) { Class type = fields[i].getType(); String name = fields[i].getName(); String o_1; if(isSingle(type)) { try { fields[i].setAccessible(true); if(type != Character.TYPE &amp;&amp; !type.equals(String.class)) { if(!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)){ if(type.equals(Double.TYPE)) { fields[i].setDouble(o, Double.longBitsToDouble(sp.getLong(name, 0L))); } else if(type.equals(Float.TYPE)) { fields[i].setFloat(o, sp.getFloat(name, 0.0F)); } else if(type.equals(Long.TYPE)) { fields[i].setLong(o, sp.getLong(name, 0L)); } else if(type.equals(Boolean.TYPE)) { fields[i].setBoolean(o, sp.getBoolean(name, false)); } } else { fields[i].setInt(o, sp.getInt(name, 0)); } } else { o_1 = sp.getString(name, (String)null); if(null != o_1) { fields[i].set(o, o_1); } } } catch (Exception e) { } } else if(isObject(type)) { Object tempValue = getObject(context, fields[i].getType()); if(null != tempValue) { fields[i].setAccessible(true); try { fields[i].set(o, tempValue); } catch (Exception e) { } } } else { //json数据解析 } } } return (T) o; } 主要的思想就是遍历javabean所有的属性对象，取出，按照类型一个个的存入XML文件中。取出时也是同时转成了存入的形式，很方便利 读写List&lt;Javabean&gt;对于list&lt;javabean&gt;，不太适合用上面的方法，一般来说不太会存这种数据，数据量比较大。如果有这个需求，可以把list&lt;javabean&gt;转成json形式，然后存入xml文件中。关于Javabean数据转成json会在另一篇叙述。 读写图片资源所谓的读写图片，个人感觉用处不大，先说一下思路。其实也很简单，就是通过base64将输出流转成string。代码奉上： private void saveBitmapToSharedPreferences(Context context,String key,Bitmap bitmap){ //第一步:将Bitmap压缩至字节数组输出流ByteArrayOutputStream ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream(); bitmap.compress(CompressFormat.PNG, 80, byteArrayOutputStream); //第二步:利用Base64将字节数组输出流中的数据转换成字符串String byte[] byteArray=byteArrayOutputStream.toByteArray(); String imageString=new String(Base64.encodeToString(byteArray, Base64.DEFAULT)); //第三步:将String保持至SharedPreferences SharedPreferences sharedPreferences=context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); Editor editor=sharedPreferences.edit(); editor.putString(key, imageString); editor.commit(); } private Bitmap getBitmapFromSharedPreferences(Context context, String key, Object defValue){ SharedPreferences sharedPreferences=getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); //第一步:取出字符串形式的Bitmap String imageString=context.sharedPreferences.getString(key,defValue); //第二步:利用Base64将字符串转换为ByteArrayInputStream byte[] byteArray=Base64.decode(imageString, Base64.DEFAULT); ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(byteArray); //第三步:利用ByteArrayInputStream生成Bitmap Bitmap bitmap=BitmapFactory.decodeStream(byteArrayInputStream); return bitmap; } 结束简单叙述了下SharedPreferences的使用，毕竟作为Android中几个主要的存储数据的方式，熟练掌握还是 非常有必要的。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus翻译]]></title>
    <url>%2F2017%2F07%2F16%2FeventBus%2F</url>
    <content type="text"><![CDATA[这篇文章是RxBus的权威文章的翻译,原文，也算是写Retrofit+RxJava学习的开端 ，在以后的博客中会陆续介绍这种框架使用的好处（可能不会连续发布）。这篇文章有三个部分： 1.事件总线快速入门 2.用RxJava实现事件总线 3.这种方法的离别思念 “RxBus”将不会成为一个库。实现事件总线RxJava是如此容易以至于它不能作为一个独立的库。 第1部分：什么是事件总线？让我们来谈谈两个似乎相似的概念：观察者模式和发布 - 订阅模式。观察者模式这是一个发展模式，借助此，你的类或主对象（被称为可观察者）利用相关信息（事件）通知其他感兴趣的类或对象（称为观察者）。发布 - 订阅模式发布 - 订阅模式的目标和观察者模式的目标是完全一样的，即你想要一些其他的类来了解正在发生的某些事件。尽管如此，观察者模式和发布 - 订阅模式之间存在一个重要的语义差别：发布 - 订阅模式的重点是外界“广播”的消息。观察者并不关注事件传给谁，而只关注事件是否已经传出。换句话说，观察者（发布者）并不关注谁是观察员（订阅者）。为什么匿名？它允许这个东西叫做“脱钩”，这是计算机编程具有良好的口碑。在设计中，你想尽可能的保持低耦合。通常情况下，你会期望发布者对每个它需要通知的用户有直接的了解，所以当事件或消息已准备就绪时，它可以去通知他们每个人。但随着事件的总线的出现，发布者被解除该任务，并且这种独立性有所帮助，因为发布者和订阅者不必有建立两者之间相关性的逻辑代码。换句话说“自觉低耦论”是你的代码在书写时就应该所思考的，这是程序员应该有的水平。如何匿名？在发布 - 订阅模式中一个很自然的问题是：你如何真正地实现发布者和订阅者之间的匿名？一个简单的方法是得到一个中间人，让那个中间人负责所有的通信。而事件总线就是这样的一个中间人。事件总线就是这么简单。常用于Android的使用的两个事件总线库是otto和EventBus。网上有大量的帖子解释如何在你的手机应用程序中实现它们。 第2部分：用总线RxJava实现事件（？？是“在”还是“用”）我已经将使用Android上RxJava的显示世界的例子粘贴在这个GitHub库上，所以我会坚持展示其完整的实现方式。下面是执行的部分代码： // this is the middleman object public class RxBus { private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); public void send(Object o) { _bus.onNext(o); } public Observable&lt;Object&gt; toObserverable() { return _bus; } } 你现在有一个事件总线可以使用了。这是你如何将事件发布到总线： @OnClick(R.id.btn_demo_rxbus_tap) public void onTapButtonClicked() { _rxBus.send(new TapEvent()); } 这是你如何倾听来自其他片段/服务等。 _rxBus.toObserverable() .subscribe(new Action1&lt;Object&gt;() { @Override public void call(Object event) { if(event instanceof TapEvent) { _showTapText(); }else if(event instanceof SomeOtherEvent) { _doSomethingElse(); } } }); 在这个例子中，我们后从顶部片段（绿色部分）的事件，并从底部片段（蓝色部分）中（通过总线）收听。在下面这个例子中，我们从顶部片段（绿色方）发布事件，并从底部片段（蓝色部分）收听（通过事件总线）。 第3部分 - 离别的思念死亡事件 在一些情况下，知道是否有观察者监听当前总线是非常有用的。比如，如果你使用事件总线来处理你的GCM推送通知），如果应用程序是在前台 ，此时你不希望发送推送通知，这时，监听“死亡事件”是非常重要的。例如，在不久前发布的婚礼派对，我们增加了“信息”到我们的应用程序。如果用户的应用程序开启（因而具有至少一个或更多的听众到总线），我们不会发送推送通知，但如果他们的应用程序在后台，那么我们发送推送通知，让他们知道聊天信息。当一个事件被发布到事件总线后，如果没有用户在听，会返回一个死亡事件。如果我们得到一个死亡事件，推送通知的将被发送出去。你将怎样利用RxBus来实现呢？ 事实上，这很容易。受试者有一个有用的方法hasObservers，这将准确的告诉我们实现方式。这被添加RxJava的1.x release 中，所以你必须要安装RxAndroid的最新版本才能看到这种方法（0.23.0）。如果你只是想在Andr​​oid应用程序中使用事件总线，你可能最好使用otto（强烈推荐）或EventBus库 。Otto有一个由注解推动的干净的API，可能更为简单易用。 虽然这篇文章写得很好，翻译的不好，以下的博客将会介绍EventBus的一般使用和RXJava及RxBus的使用。Csdn原文]]></content>
      <categories>
        <category>page</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿Big-Bang实现]]></title>
    <url>%2F2016%2F10%2F24%2Fbigbang1%2F</url>
    <content type="text"><![CDATA[原文地址前几天去看了锤子的发布会，没想到这次还是诚意满满。作为程序员，就关注了在本次发布会出现的两大创意（其实只能算得上微创新）。第一个就是本次要说的big-bang，另一个是One Step。 先简要介绍一下One Step，毕竟本次的主题不是他。在Android中其实已经有了相关的介绍，不知道各位基友注意到没有。早在API11的时候官方推出一个新的API—Drag and Drop。官方链接。无法科学上网的童鞋们只能通过下图（截取了整个界面）来看这个功能的实现。图片下载，图片太大了详情请看—链接大神的解析 下面来进入BigBang的学习过程，通过发布会上简简单单的演示，我们可以看到一共有三步，系统级拦截长触摸事件+系统剪切板+分词技术。这三个技术现在都比较成熟，不要担心。如果想实现系统级的拦截可以使用Xposed技术，用来拦截,在这里不做赘述。现在主要分为两部分讲实现BigBang技术的实现。 1. 实现基本功能 本部分主要介绍系统剪切板，中文/英文分词的实现和问题的解决 1，使用系统剪切板 首先启动一个服务，在其他软件上使用剪切板时可以监控通知软件有新的内容出现，并在通知栏上进行提示用户操作。 ClipServer.java（其他方法暂不赘述） @Override public int onStartCommand(Intent intent, int flags, int startId) { final ClipboardManager clipboardManager = (ClipboardManager) getSystemService (CLIPBOARD_SERVICE); clipboardManager.addPrimaryClipChangedListener(() -&gt; { if (clipboardManager.hasPrimaryClip()) { if (clipboardManager.getPrimaryClipDescription().hasMimeType( ClipDescription.MIMETYPE_TEXT_PLAIN)) { ClipData primaryClip = clipboardManager.getPrimaryClip(); if (primaryClip != null) { ClipData.Item item = primaryClip.getItemAt(0); if (item != null &amp;&amp; !TextUtils.isEmpty(item.getText().toString())) { startNofi(item.getText().toString()); } } } } }); return super.onStartCommand(intent, flags, startId); } private void startNofi(String s) { manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Intent resultIntent = new Intent(this, ReceiverClip.class); resultIntent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); resultIntent.putExtra(ReceiverClip.EXTRA_TEXT, s); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher); notifyBuilder = new NotificationCompat.Builder(this) .setLargeIcon(bitmap) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(getResources().getText(R.string.nofi_tongzhi)) .setContentText(getResources().getText(R.string.nofi_context)) .setWhen(System.currentTimeMillis()) .setTicker(&quot;Big bang&quot;) .setOngoing(true) .setAutoCancel(true) .setContentIntent(pendingIntent); manager.notify(121, notifyBuilder.build()); } 在MainActivity上进行启动服务，在这里童鞋们可以添加一些（XX）的技术，尽量使这个服务线程保活。比如双进程守护（像NDK双进程守护），系统的辅助服务，相互唤醒（全家桶），悬浮窗1px等等（这样的技术在此不做描述，毕竟国内的环境，，，，）。 MainActivity.java private void initData() { Intent intent = new Intent(MainActivity.this, ClipServer.class); startService(intent); } 系统剪切板就是这点内容，下面是是分词技术。 2.中文/英文分词技术 通过百度/谷歌查询可知分词是比较成熟的，像Word分词器，IKAnalyzer分词器等等，使用Java实现的分词器（知名的）十多个。 在本文中主要使用的是IKAnalyzer+Lucene（本地）。做过功课的童鞋们大概也看出来分词器需要web端实现或添加大字典。本人猜测锤子的分词是在服务端实现的，毕竟本地实现分词不仅需要大字典还有运算时的高耗，在本地实现运算一段100字左右的段落，会占用大约2s-3s的时间（我的渣渣手机），同时还有IKAnalyzer.cfg.xml，ext_stopword.dic两个文件，作为字典，配置文件。 言归正传，我用的是IKAnalyzer-2012_u3(好像不更新了)，和Lucene的三个包，lucene-analyzers-3.1.0.jar，lucene-core-3.6.0.jar，lucene-highlighter-3.6.0-sources.jar。在Maven仓库里面没有Lucene的三个包（有点老），大家在官网上下，或者在本文最后提供的地址中去爬。 使用jdk1.8的童鞋们在build.gradle中添加 compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } 在解析界面，使用代码： String text = getIntent().getStringExtra(EXTRA_TEXT); if (!TextUtils.isEmpty(text)) { List&lt;String&gt; keywordList = new ArrayList&lt;&gt;(); try { byte[] bt = text.getBytes(); InputStream ip = new ByteArrayInputStream(bt); Reader read = new InputStreamReader(ip); IKSegmenter iks = new IKSegmenter(read, true);//true开启只能分词模式，如果不设置默认为false，也就是细粒度分割 Lexeme t; while ((t = iks.next()) != null) { keywordList.add(t.getLexemeText()); mLayout.addTextItem(t.getLexemeText()); } } catch (IOException e) { e.printStackTrace(); } } 就是这么短的代码量，是不是很惊喜，如此简单的实现。好了，现在实现界面。 3，分词界面 主要就是一个流式布局，TouchEvent事件。在触摸一个词时加入StringBuilder中。下面放出一个大神写的仿锤子布局（本人实力不够，，，，）。 BigBangLayout.java @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSize = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight(); int contentWidthSize = widthSize - mActionBar.getContentPadding(); int heightSize = 0; int childCount = getChildCount(); int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); mLines = new ArrayList&lt;&gt;(); Line currentLine = null; int currentLineWidth = contentWidthSize; for (int i = 0; i &lt; childCount; i++) { View child = getChildAt(i); if (mActionBar == child) { continue; } child.measure(measureSpec, measureSpec); if (currentLineWidth &gt; 0) { currentLineWidth += mItemSpace; } currentLineWidth += child.getMeasuredWidth(); if (mLines.size() == 0 || currentLineWidth &gt; contentWidthSize) { heightSize += child.getMeasuredHeight(); currentLineWidth = child.getMeasuredWidth(); currentLine = new Line(mLines.size()); mLines.add(currentLine); } Item item = new Item(currentLine); item.view = child; item.index = i; item.width = child.getMeasuredWidth(); item.height = child.getMeasuredHeight(); currentLine.addItem(item); } Line firstSelectedLine = findFirstSelectedLine(); Line lastSelectedLine = findLastSelectedLine(); if (firstSelectedLine != null &amp;&amp; lastSelectedLine != null) { int selectedLineHeight = (lastSelectedLine.index - firstSelectedLine.index + 1) * (firstSelectedLine.getHeight() + mLineSpace); mActionBar.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(selectedLineHeight, MeasureSpec.UNSPECIFIED)); } int size = heightSize + getPaddingTop() + getPaddingBottom() + (mLines.size() - 1) * mLineSpace + mActionBarTopHeight + mActionBarBottomHeight; super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(size, MeasureSpec.EXACTLY)); } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { int top; int left; int offsetTop; Line lastSelectedLine = findLastSelectedLine(); Line firstSelectedLine = findFirstSelectedLine(); for (int i = 0; i &lt; mLines.size(); i++) { Line line = mLines.get(i); List&lt;Item&gt; items = line.getItems(); left = getPaddingLeft() + mActionBar.getContentPadding(); if (firstSelectedLine != null &amp;&amp; firstSelectedLine.index &gt; line.index) { offsetTop = -mActionBarTopHeight; } else if (lastSelectedLine != null &amp;&amp; lastSelectedLine.index &lt; line.index) { offsetTop = mActionBarBottomHeight; } else { offsetTop = 0; } for (int j = 0; j &lt; items.size(); j++) { Item item = items.get(j); top = getPaddingTop() + i * (item.height + mLineSpace) + offsetTop + mActionBarTopHeight; View child = item.view; int oldTop = child.getTop(); child.layout(left, top, left + child.getMeasuredWidth(), top + child.getMeasuredHeight()); if (oldTop != top) { int translationY = oldTop - top; child.setTranslationY(translationY); child.animate().translationYBy(-translationY).setDuration(200).start(); } left += child.getMeasuredWidth() + mItemSpace; } } if (firstSelectedLine != null &amp;&amp; lastSelectedLine != null) { mActionBar.setVisibility(View.VISIBLE); mActionBar.setAlpha(1); int oldTop = mActionBar.getTop(); int actionBarTop = firstSelectedLine.index * (firstSelectedLine.getHeight() + mLineSpace) + getPaddingTop(); mActionBar.layout(getPaddingLeft(), actionBarTop, getPaddingLeft() + mActionBar.getMeasuredWidth(), actionBarTop + mActionBar.getMeasuredHeight()); if (oldTop != actionBarTop) { int translationY = oldTop - actionBarTop; mActionBar.setTranslationY(translationY); mActionBar.animate().translationYBy(-translationY).setDuration(200).start(); } } else { if (mActionBar.getVisibility() == View.VISIBLE){ mActionBar.animate().alpha(0).setDuration(200).setListener(mActionBarAnimationListener).start(); } } } 还有上面的几个按钮在BigBangActionBar.java private void initSubViews() { Context context = getContext(); mBorder = ContextCompat.getDrawable(context, R.drawable.bigbang_action_bar_bg); mBorder.setCallback(this); mSearch = new ImageView(context); mSearch.setImageResource(R.mipmap.bigbang_action_search); mSearch.setOnClickListener(this); mShare = new ImageView(context); mShare.setImageResource(R.mipmap.bigbang_action_share); mShare.setOnClickListener(this); mCopy = new ImageView(context); mCopy.setImageResource(R.mipmap.bigbang_action_copy); mCopy.setOnClickListener(this); addView(mSearch, createLayoutParams()); addView(mShare, createLayoutParams()); addView(mCopy, createLayoutParams()); setWillNotDraw(false); mActionGap = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 15, getResources().getDisplayMetrics()); mContentPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, getResources().getDisplayMetrics()); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int childCount = getChildCount(); int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); for (int i = 0; i &lt; childCount; i++) { View child = getChildAt(i); child.measure(measureSpec, measureSpec); } int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); setMeasuredDimension(width, height + mContentPadding + mSearch.getMeasuredHeight()); } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { int width = getMeasuredWidth(); int height = getMeasuredHeight(); layoutSubView(mSearch, mActionGap, 0); layoutSubView(mShare, width - mActionGap * 2 - mShare.getMeasuredWidth() - mCopy.getMeasuredWidth(), 0); layoutSubView(mCopy, width - mActionGap - mCopy.getMeasuredWidth(), 0); Rect oldBounds = mBorder.getBounds(); Rect newBounds = new Rect(0, mSearch.getMeasuredHeight() / 2, width, height); if (!oldBounds.equals(newBounds)) { ObjectAnimator.ofObject(mBorder, &quot;bounds&quot;, new RectEvaluator(), oldBounds, newBounds).setDuration(200).start(); } } 至此大家可以看看实现。一般来说剪切板需要保存历史记录，下面开始实现数据库。喜欢使用原生数据库的实现，下节可以不用看了，在本文中数据库使用GreenDao实现数据库操作。相信大家肯定接触过，下面只是简单的介绍一下。 3. 添加数据库等使用技术 在main下面建立java-gen(大家都这样写，其实无所谓)，在build.gradle中设置 sourceSets{ main{ java.srcDirs=[&apos;src/main/java&apos;,&apos;src/main/java-gen&apos;] } } 还有一个 compile ‘de.greenrobot:greendao:1.3.7’，将greendao的包导进去。接下来开始建立依赖库，在依赖库的build.gradle写： apply plugin: &apos;java&apos; dependencies { compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;de.greenrobot:greendao-generator:1.3.1&apos; } sourceCompatibility = &quot;1.8&quot; targetCompatibility = &quot;1.8&quot; 在java文件中写 public static void main(String[] args) throws Exception { // 正如你所见的，你创建了一个用于添加实体（Entity）的模式（Schema）对象。 // 两个参数分别代表：数据库版本号与自动生成代码的包路径。 Schema schema = new Schema(1, &quot;com.longshihan.sqlite&quot;); // 当然，如果你愿意，你也可以分别指定生成的 Bean 与 DAO 类所在的目录，只要如下所示： // Schema schema = new Schema(1, &quot;me.itangqi.bean&quot;); // schema.setDefaultJavaPackageDao(&quot;me.itangqi.dao&quot;); // 模式（Schema）同时也拥有两个默认的 flags，分别用来标示 entity 是否是 activie 以及是否使用 keep sections。 // schema2.enableActiveEntitiesByDefault(); // schema2.enableKeepSectionsByDefault(); // 一旦你拥有了一个 Schema 对象后，你便可以使用它添加实体（Entities）了。 addNote(schema); // 最后我们将使用 DAOGenerator 类的 generateAll() 方法自动生成代码，此处你需要根据自己的情况更改输出目录（既之前创建的 java-gen)。 // 其实，输出目录的路径可以在 build.gradle 中设置，有兴趣的朋友可以自行搜索，这里就不再详解。 new DaoGenerator().generateAll(schema, &quot;D:\\1\\BigBang1\\app\\src\\main\\java-gen&quot;); } /** * @param schema */ private static void addNote(Schema schema) { // 一个实体（类）就关联到数据库中的一张表，此处表名为「Note」（既类名） Entity note = schema.addEntity(&quot;Clip&quot;); // 你也可以重新给表命名 // note.setTableName(&quot;NODE&quot;); // greenDAO 会自动根据实体类的属性值来创建表字段，并赋予默认值 // 接下来你便可以设置表中的字段： note.addIdProperty(); note.addStringProperty(&quot;text&quot;).notNull(); // 与在 Java 中使用驼峰命名法不同，默认数据库中的命名是使用大写和下划线来分割单词的。 // For example, a property called “creationDate” will become a database column “CREATION_DATE”. note.addStringProperty(&quot;comment&quot;); note.addDateProperty(&quot;date&quot;); } 这个全凭自己的需求。建立表等，这种方法比较简单，但适合扩展，或者使用注解的方式生成。运行或在java-gen中生成表名的类Clip，ClipDao，DaoMaster和DaoSession这三个。新建一个DaoManager,来管理ClipDao。或者在Application 中实现也可。所以在服务中就可以添加信息。 String comment = primaryClip.getDescription().toString(); Clip note = new Clip(null, item.getText().toString(), comment, new Date()); App.getInstance().App_session().getClipDao().insert(note); 在MainActivity 可以使用RecyclerView 列表。将数据库中所有数据取出，显示在界面中。 效果图： 以上这些就是全部内容，附上我的github地址：链接]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于学习RN和微信小程序一个月随感]]></title>
    <url>%2F2016%2F10%2F14%2Frn1%2F</url>
    <content type="text"><![CDATA[2016.10-11.14是我学习（业余时间）RN和微信小程序一个月了，学了一些控件和事件。现在在这里做一下整理和总结。 一、React Native的实现和相关问题的解决 React Native的安装 React Native 是FaceBook去年推出的移动端通用代码的一套解决方案。总得来说，在目前为止是比较完善的。但官方的一些Demo是向IOS开发的，Android平台运行时比较麻烦的。Github地址，官方有专门的人进行维护，而且更新的速度很快。Demo也在里面。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先提到React Native，肯定首先提到JSX语法，是一种构造虚拟的DOM结构体,这是FaceBook团队开发。JSX可以把Html的标签直接编写JavaScript对象，使用的是Xml-like语法，这种语法需要通过JSXTransformer翻译成真实可用的JavaScript代码。既然JSX是语法，肯定有其遵循的一套书写方案。在这里就不做赘述，需要了解的可以去百度。 在这里说一下需要注意的几点，否则在运行时会报错。 1. React Native在导入其他模块时，在Component里面使用的对象的首字母大写。 2. JSX只能执行一次运行结束的JavaScript语句（不清楚这样表述正不正确），所以像ifelse这样的无法执行。 3. JSX只能执行一个代码块，就是只能存在一个根节点。 4. 相关JSX的关键字和HTML的关键字冲突 注意以上四点就可以避开很多的坑。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，React Native运行的是ES6(或者兼容前代)的执行标准，如果小伙伴不了解ES6可以先去看相关的视频、书籍，毕竟ES6是下一代JavaScript的标准，与现阶段使用的JavaScript还是有不少区别的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 好了，介绍完前提的技术，现在可以进行React Native的Window下的安装了。 1，安装JDK,SDK，并写入环境变量中，安装git，Python（非必须，但这貌似是开发者的标配了） 2，官网上安装Node.js,官网，配置环境变量 3，安装react-native命令行工具，npm install -g react-native-cli &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK，其实就这两步，然后就可以在相关的文件夹中进行生产代码了。 1react-native init MyProject &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要等大约半个小时，，，网络好的话，小伙伴还可以使用代理，请百度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载完成后在控制台会出现”react native android ”字样。这就说明下载成功。目录： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出React Native 支持Android和IOS的操作，我们的操作的入口就是index.android.js，而IOS同理。 React Native的运行 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到了这个步骤，说明已经下载成功，上方的步骤已经完成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么现在可以打开两个软件：Android Studio和Webstorm(使用Viual Studio Code也可)。 将Android项目（上图的android文件夹）导入到Android Studio中，最终图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在build.gradle中可以看出引用了 1compile &quot;com.facebook.react:react-native:+&quot; // From node_modules &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个maven中有 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK系列的网络请求框架，加载图片的fresco,还有支持react的jar文件。希望童鞋在使用添加ReactNative的时候勿要出现重复引用，模块重合。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将整个文件夹导入Webstorm中，目录结构： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里还要设置js的解析方式和运行方式， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意command设置为Start，就可以了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里要设置为JSX，才可以解析。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你以为到这里就可以运行了？NO，工欲善其事必先利其器，我们还是先导入一个ReactNative的模板吧。Github链接直接下载下来，导入里面的ReactNative.jar文件就可以了，是WebStorm里面的Import Settings…..接下来我们就可以愉快的玩耍了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将Android项目跑到手机上，（如果Gradle出现问题，检查下版本，是不是高于23.0.1，还有gradle的版本不要太新，我是1.3.1正常编译。现阶段的兼容性还是有问题的，出现问题的小伙伴可以在下方留言） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后WebStorm可以直接运行，在控制台可以看到npm start就说明已经在启动了。看到React packager ready.就说明已经跑起来了，在浏览器中打开： 1http://localhost:8081/index.android.bundle?platform=android &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果出现如下图的信息就说明正常启动，下一步就是修改软件的局域网地址。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果网速不好，可以修改这里的设置网络延时时间， 1const MAX_WAIT_TIME = 120000; 文件在 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个文件曾经改变过位置，直接百度的话，可能找不到路径，以最新的路径为准。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果小伙伴的手机是小米手机，请在开发者选项里面将miui优化关闭，然后重启一下就可以了，软件刚安装有一个选项是在其他应用的上层显示，请选中。这样才能进入界面。 PS:如果现在才使用ReactNative的童鞋会发现，在init项目的时候会安装yarn，，，倒霉的npm管理器的迭代会直接影响我们构建的速度，没有办法，只好在npm中装在装一个yarn,安装方式相同，npm install -g yarn，（-g是全局安装，会直接安装在AppData/npm中），重新构建 项目的时候会发现明显快了不少。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件刚进入一般都是红底黑字，这是ReactNative 的错误界面（就是这个特色）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开Dev setting 设置电脑的IP和端口（比如192.168.0.100：8081等），前提必须在一个局域网中，重新reload一下，就可以看到界面。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是错误的界面（ps:局域网链接失败，可以cmd打开控制台输入ipconfig查看当前的局域网ip） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们会发现这个界面上的文字与index.android.js上书写的文字雷同，我们改变index.android.js上的文字，重新reload会发现界面也随之变化。我们可以得出一个结论，这个文件就是ReactNative的入口文件。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此，ReactNative的运行已经实现。 3. React Native与原生的调用 现在React Native已经可以跑起来了。大家可以愉快的玩耍了。上图就是界面布局，下图就是布局样式： React Native遵循Flex布局方式，详情请看官方文档 对于一些控件的使用，可以参考官方文档，在这里需要注意一下，对于Android来说，官方文档可能更新有些慢，有一些被放弃的属性在官方文档上依然有体现。请注意Image控件，对于Android目录下mipmap和drawable目录下的图片必须保证正确引用，引用方式： &gt;&gt; &lt;image source={{uri:XXXX}}/&gt; 请注意{}在Component非常常见，比如加注释。 对于一般的操作以后的博客再讲，本次主要是将如果调用原生控件。 现在演示一下调用Toast控件。 1.首先我们了解到官方有一个管理toast的js库， import Toast from &apos;react-native-root-toast&apos;; 写一个工具类实现Toast输出。所以我们先安装一个库下载这个react-native-root-toast模块。使用npm安装 npm install react-native-root-toast &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在webstorm中没有找到这个支持包的话，也没关系，直接新建一个js文件,叫ToastUtil.js.直接导入这个包，软件会提示你安装，然后就安装好了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出已经装好了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ToastUtil写法： import Toast from &apos;react-native-root-toast&apos;; export const toastShort = (content) =&gt; { if (toast !== undefined) { Toast.hide(toast); } toast = Toast.show(content.toString(), { duration: Toast.durations.SHORT, position: Toast.positions.CENTER, shadow: true, animation: true, hideOnPress: true, delay: 0 }); }; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这只是举个例子，文件在根目录，所以在index.android.js中导入： import {toastShort} from &apos;ToastUtil&apos; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击事件弹出： export default class yuansheng extends Component { render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; Shake or press menu button for dev menu test &lt;/Text&gt; &lt;TouchableOpacity onPress={()=&gt; { this.showtoast() }}&gt; &lt;Text&gt;Toast&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } showtoast() { toastShort(&quot;点击&quot;); } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者直接使用官方封装好的js文件，ToastAndroid。ToastAndroid在react-native/Libraries/Components/中，通过下图可以看出： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方封装了很多了原生控件，以供使用，这也是新版更新过来的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用ToastAndroid， import * as ToastAndroid from &quot;react-native/Libraries/Components/ToastAndroid/ToastAndroid.android&quot;; showtoast() { ToastAndroid.show(&apos;点击&apos;, ToastAndroid.SHORT); } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别忘了在import导入TouchableOpacity模块。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，就可以使用Toast功能了。 在新Android项目中打包React Native &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较关心的是在已有的项目打包使用ReactNative，通过上文可知ReactNative使用的是Bundle，将文件传到目录，解压显示（可能流程描述的不准确）。 所以我们可以通过对比和原有项目的联系。添加文件实现ReactNative功能。 1，配置node_modlues,我建议直接把存在的这个文件夹拷贝过去，因为下载速度，，稍微有点慢。放在和Android 项目同级，同时将package.json和index.android.js拷贝过去，这个版本文件和入口。修改package.json里面的内容，比如项目名称。 2，现在修改Android项目的文件，在项目的build.gradle添加ReactNative的仓库， url &quot;$rootDir/../node_modules/react-native/android&quot; setting.gradle中添加 rootProject.name = &apos;yuansheng&apos;//所在文件夹的名称 相关NDK的支持添加上app的build.gradle中添加 splits { abi { reset() enable enableSeparateBuildPerCPUArchitecture universalApk false // If true, also generate a universal APK include &quot;armeabi-v7a&quot;, &quot;x86&quot; } } // applicationVariants are e.g. debug, release applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; // For each separate APK per architecture, set a unique version code as described here: // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits def versionCodes = [&quot;armeabi-v7a&quot;:1, &quot;x86&quot;:2] def abi = output.getFilter(OutputFile.ABI) if (abi != null) { // null for the universal-debug, universal-release variants output.versionCodeOverride = versionCodes.get(abi) * 1048576 + defaultConfig.versionCode } } } compile &quot;com.facebook.react:react-native:+&quot; // From node_modules task copyDownloadableDepsToLibs(type: Copy) { from configurations.compile into &apos;libs&apos; } 设置代码：在androidmanifast中添加： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; &lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt; Application要实现ReactApplication接口， private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { @Override protected boolean getUseDeveloperSupport() { return BuildConfig.DEBUG; } @Override protected List&lt;ReactPackage&gt; getPackages() { return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage() ); } }; @Override public ReactNativeHost getReactNativeHost() { return mReactNativeHost; } 需要使用的入口是继承ReactActivity。具体如何集成，我也没有找到能够100%一次性通过编译的，可能现阶段不完善吧。ReactNative的介绍先到一阶段。原本想出一个微信小程序的，后来又不火了，就放弃了]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android新布局-ConstraintLayout详解]]></title>
    <url>%2F2016%2F07%2F27%2Fconstranintlayout%2F</url>
    <content type="text"><![CDATA[原文地址谷歌在2016年的IO大会上推出的一种新的布局方式—-ConstraintLayout，这局是一种约束型的布局方式。在设置和介绍上类似IOS的自动布局。 先放上Google的官方解析地址：点击链接 ，虽然这个地址我从来没进去过，现在另外附上一份这个官方Demo的Github地址，git： https://github.com/googlecodelabs/constraint-layout.git如果在Android studio中不会使用github，还是去找找相关资料了，毕竟这部分技能应该算的上是程序员必备了。那么，从下面开始详细介绍ConstraintLayout这个布局的使用。 1.准备第一步，工欲善其事首先先装上Android studio的新版，不要求是最新版，但一定是要超过2.2的版本，截止本文结束前，当前版本是2.2preview6。如果打算升级，但现在是2.1.2等稳定版，则选择更新，选择Update dialog of your IDE settings.在这里选择DEV版本。虽然肯定不会升级成功，下面直接附上下载地址（PS：官方网址，需要翻墙），官方下载地址，如果由于种种原因无法翻墙的基友们请看此处，百度云下载。 第二步，必先利其器 理所当前，使用新的布局方式首先应该导包，ConstraintLayout所在的文件是android.support.constraint.ConstraintLayout，而这个文件在（箭头所指） 使用Library Dependency可以直接导入。不明白Maven，Gradle等配置的童鞋，建议去找一些资料看，毕竟这在以后的开发中还是挺重要的。 到了这一步终于可以使用ConstraintLayout这种布局方式了。 在实际操作前先说一下他的性质。 先看ConstraintLayout作为一个ViewGroup的子类，而他并没有没有重载onDraw的方法，他的onLayout（）方法也非常简单， 可以看出所以源码中，他内部的子view都是以相对关系存在的，所以只要计算出子view的坐标，就能推算出其他childview该放在布局哪个位置。所以在他的layout的过程也十分简单。 对于他的OnMeasure（）方法，有兴趣的同学可以去看看。另外附上一张RelativeLayout的布局，同样继承于ViewGroup，在他的onLayout（）方法中，见下图： 可以差不多的看出ConstraintLayout与RelativeLayout对于子控件的排列方式差不多，可以将ConstraintLayout理解为RelativeLayout的升级版（我也不知道这个名称是否得当，欢迎斧正）。可以将ConstraintLayout当做RelativaLayout的布局使用，以及对于子控件的摆放，各位童鞋都有一些印象了吧。、 2.约束性关系在这个布局中，最为关键重要的就是约束性关系这个概念。我的表达能力不是很好，童鞋们理解就好，不理解的话请参考关系数据库完整性约束（大概意思）。约束性关系帮助你保持子控件与子控件对齐或者存在相互的关系. 你可以使用锚点来约定子控件之间存在何种对齐方式。如下图的ButtonA与ButtonB。我们从ButtonA的锚点指向ButtonB，并约束了96dp的间距，则此时移动ButtonB则会与ButtonA保持96dp的距离，而且在移动时的ButtonA也会移动。而操作ButtonA则是很随意，这就是约束性的关系，ButtonA约束了ButtonB的行为。下图是动态操作，表述上文所述的一些行为。 下面介绍一下完整的整体的各个含义：其中四个角的位置可以将控件缩放的操作点，而在四个边上的圆圈是锚点，（PS：锚点是对应的，上下的锚点只能和上下行的锚点链接，不能和左右的锚点链接），中间的椭圆形式句柄（？），这个的作用是将水平方向的控件内部的字体水平对齐。下图详见操作（有一些操作现在没有讲到，比如自动对齐，这个将会在下面讲）： 3.正文上面的内容只是ConstraintLayout布局的一些基础知识点，现在我们来正式的看ConstraintLayout的使用。 我们先把一张图片附在布局中，成像效果如下：一些初学者会以为右侧的波浪线是图片的黑白平衡，通道，色差之类的，但很抱歉，什么也不是，是Android studio的布局中加载图片的一种显示方式。就像Button控件中有一个句柄一样，图片并没有这个东西。现在我们把眼光移向右上角，会发现出现了一个2字，，打开这个2（这个是错误的个数）会发现里面报了若干个（2个）错误（警告），下面来给大家讲解一下这些都是什么含义。其中第一个是：此子控件缺少约束，否则按左上角（0,0）的位置进行判断子控件的位置，这个错误在Relativelayout布局非常常见，可以不必理会。在这里比较关键的是第二个警告，此控件缺少contentDescription这个节点，而这个节点同样也是新增的内容，是Android新版新增添的功能-无障碍阅读的一种实现。对于Android新增的无障碍阅读功能在系统设置-无障碍里面（由于国产ROM的百花齐放，这个功能自己摸索去），这个功能的主要作用是给一些视力障碍的群体正常的使用Android系统，在触摸某些设置的控件时会发出提示音（使用Google提供的Talk软件）。而这个的操作就是依靠contentDescription这个新属性。添加地点在：点开之后是选择value，在@string/XXX下面，启动无障碍模式，会播报在此处选择的文字。现在又出现一个新的面板-Properties，是对新功能的补充，如果大家还是怀念原来的样式，则打开方式是：右上角的 左右箭头的符号，顿时就有爱了，还是原来的配方，还是原来的味道。 好了，扯了这么多闲话，现在正是创建约束性的操作，在通过上面的学习，相信大家对这个约束性的关系和创建约束肯定很感兴趣。 1. 手工创建约束性的操作 容我先创建两个可亲可爱的按钮（Button），点击A Button右侧的圆圈，右侧的圆圈会出现类似呼吸灯的状态，点住按钮会出现一个箭头，将箭头想右引导，如果成功A Button会移动到B Button的旁边，而且A Button的呼吸灯变成红色（？原谅我没看出来）。到这步就手工创建好了两者的约束，可以自由操作了。 具体操作如下： 这是两个控件中的手工创建约束，下面是单个控件与上层布局的约束。这种方式比较好的地方在于可以与左右上下限定所谓的位置，类型LinearLayout的百分比的方式，在代码中的体现是： 比较好的融合了RelativeLayout和LinearLayout的优点。（对于百分比布局，将会在以后的文章中有详述） 下面来说一下两个控件之间的基准约束条件。将鼠标放置到Button A句柄处，当句柄开始变色（？）时用鼠标引导句柄，此时会从句柄处引申一条连接线，将此连接线连接到Button B 的句柄处，会发现Button A会移动到与Button B平齐（文字）的地方。（请注意右上角的警告数字，按照个人需求设置）。在代码中的体现是在下图是如何设置的动态图 好了，个人的设置大约就是这样，下面开始介绍Properties面板的若干参数的含义。 这个ImageView与上层布局的约束的状态。想必各位看官们已经注意到了图中的16,50,39等数字，下面来给大家讲解一下各个数字的用处。16是当ImageView与上层布局出现约束关系时，四周与上层布局的间隔，也就是margin属性。用法一致，并没有发生改变。而50,39指的是50%和39%，相信大家看完下面的演示就会一目了然。移动这个百分比比率会影响控件在布局中的位置（演示的有点小卡），这些百分比率就是在布局中的比率的显示。在这张图中，还有一些代表意义。1.在上图中有，wrap_content，这个的含义，在新式布局中，对应的是对于wrap_content,在此就不做赘述，不知道或不明白的去面壁吧。2.，Fixed，对于这种样式，在布局中的代表含义是实际的距离，也就是我们给这个控件赋予的尺寸（指定的尺寸）。3.，AnySize，对于这种样式，让子控件占用尽可能大的所有可用空间以去适应上层布局.看到在代码中的释义是不是很熟悉，又见0dp。 2. 自动创建约束 下面来看布局上面面板的内容，有经验的同学可以很快发现这个面板和以往的有所不同。 多了下面这一排的图标，这次我们会仔细讲解一下这些图标的作用。现在我们将按照逻辑来讲一下各个图标。1.这个图标是左起第二个。作用是系统自动预测人类预期的行为而创建的约束—-简称自动创建约束（官方怎么称呼的我也不清楚）。下面展示一下自动创建的流程。开启磁铁符号，将控件放置在布局中，可以清晰的看到约束的关系在自动的创建。在新式布局中还有一种自动创建约束的按钮，左起第四个，，点击这个按钮系统会提示控件与控件，控件与布局之间的可能存在的约束关系。详情见下面的动图： 这种自动约束的好处是免除自己去创建约束，但不好的地方在于约束太多，可能有很多约束不需要，而我们怎么删除这些约束呢？下面我们来看第三个按钮，，使用这个按钮就可以将所有的约束去除。如果不打算去除所有约束，而是不想将其显示出来，则使用第一个按钮，，则可以将所有的约束关系显示/隐藏。（不贴图了，感兴趣的小伙伴们可以自己试试）对于下面几个按钮，大家可以试试，是对控件进行操作。 比如：是将控件的大小放置为可以容纳上层布局的最大的空间。 ConstraintLayout布局大约就是这些功能，现在看一下用这个布局做的一个简单的例子（丑，希望不要因为她丑而放弃他）。 在这里感谢！一叶飘舟 大神博客的帮助，带我走进ConstraintLayout布局的大门。感谢！]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>