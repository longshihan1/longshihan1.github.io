<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙逝寒Android博客</title>
  <subtitle>源码之中,了无秘密</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-22T09:00:09.079Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>龙逝寒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 系列（一） 动态代理（下）</title>
    <link href="http://yoursite.com/2017/07/18/dongtaidaili3/"/>
    <id>http://yoursite.com/2017/07/18/dongtaidaili3/</id>
    <published>2017-07-18T08:22:02.000Z</published>
    <updated>2017-07-22T09:00:09.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前两章想必大家都知道动态代理是怎么回事，本小节的内容是动态代理的实践操作了。在Android项目中如何实现按钮的防双击（防抖动）。<br>这个在Android上又叫Hook技术</p>
</blockquote>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>对于一些特定需求使用也是非常无可奈何的，比如Android里面对所有的点击事件进行一定的操作，比如防双击（防抖动），插桩等。<br>对于这种需求的解决方案肯定不止一个了，现在通用的（大众的）解决方案有六个：</p>
<p>1、每个调用的时候处理，点击第一下之后将按钮不可点击状态，轮询一定时间之后变为可点击状态（代码不贴了，估计没人会这么写）<br>2、写一个工具类，返回布尔型，在里面计算点击周期等，（同样不建议）<br>3、复写view.onClickeListener,重新定义一个抽象类，承接OnClickListener的事件，在进行处理完之后分发，</p>
<pre><code>public abstract class NoDoubleClickListener implements View.OnClickListener {
private int MIN_CLICK_DELAY_TIME = 500;

private long lastClickTime = 0;

public abstract void onNoDoubleClick(View v);

@Override
public void onClick(View v) {
    long currentTime = Calendar.getInstance().getTimeInMillis();
    if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) {
        lastClickTime = currentTime;
        onNoDoubleClick(v);
    }
    }
}
</code></pre><p>4、RxBinding操作，或者RXJava自己封装<br>  通过学习RXJava可知有一个操作符throttleFirst ,作用是在一定时间内的时间，只发送第一条事件，和debounce,作用是在一定时间没有变化才会发送事件。<br>  所以可以使用RxBinding：</p>
<pre><code>RxView.clickEvents(button)
.throttleFirst(500, TimeUnit.MILLISECONDS)
.subscribe(clickAction);
</code></pre><p>看起来是不是很简单，但是要导入Rxjava相关的框架，还会破坏butterknife的结构，小伙伴可以想想怎么写。</p>
<p>5、使用装饰器模式<br>   理论上可以实现，但没有写过，小伙伴可以试试。<br>6、动态代理<br>   本节内容的重头戏，在下部分详细概述怎么写的。</p>
<h2 id="2-动态代理实现仿双击"><a href="#2-动态代理实现仿双击" class="headerlink" title="2.动态代理实现仿双击"></a>2.动态代理实现仿双击</h2><ul>
<li>#确定需求<br>我们的具体需求是什么，android上的动态代理的形式和Java有什么不同，虽然Android程序是用java编写的（原生）。<ol>
<li>首次Android中的Activity是有生命周期的，所以要在所有使用的地方注册</li>
<li>找到所要插入的点<br> 每次使用SetOnClickListener的方法，在View的方法里面<br> <img src="http://oqsn5psbq.bkt.clouddn.com/listenerInfo.png?attname=&amp;e=1500457180&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:wBKxW0c65_h8AV2_ynVDAmoHQ0U" alt=""><br><img src="http://oqsn5psbq.bkt.clouddn.com/listener2.png?attname=&amp;e=1500458419&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:J6QURGwKDiRbLJF0RP_Z_77voRc" alt=""><br>都会使用ListenerInfo这个类，下面看看这个类<br><img src="http://oqsn5psbq.bkt.clouddn.com/listenerinfo1.png?attname=&amp;e=1500457255&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:anYDKr50ZXwFPq27ZUzjid-0eH8" alt="">   </li>
</ol>
</li>
</ul>
<p>所以我们按图索骥，一步一步的找到真正实现的接口的地方，就是在ListenerInfo的OnClickListener。对于这个类我们也可以看出，所有的触摸事件（包括滑动，长按，按键等）都是在这个位置进行监听的。<br>下面我们来写动态代理的代码：</p>
<pre><code>Class viewClass = Class.forName(&quot;android.view.View&quot;);
      Method method = viewClass.getDeclaredMethod(&quot;getListenerInfo&quot;);
      method.setAccessible(true);
      Object listenerInfoInstance = method.invoke(view);

      //hook信息载体实例listenerInfo的属性
      Class listenerInfoClass = Class.forName(&quot;android.view.View$ListenerInfo&quot;);

      Field onClickListerField = listenerInfoClass.getDeclaredField(&quot;mOnClickListener&quot;);
      onClickListerField.setAccessible(true);
      View.OnClickListener onClickListerObj = (View.OnClickListener) onClickListerField.get(listenerInfoInstance);//获取已设置过的监听器

      if (isScrollAbsListview &amp;&amp; onClickListerObj instanceof OnClickListenerProxy) {//针对adapterView的滚动item复用会导致重复hook代理监听器
          return;
      }
      //hook事件，设置自定义的载体事件监听器
      onClickListerField.set(listenerInfoInstance, new OnClickListenerProxy(onClickListerObj, proxyListenerConfigBuilder.getOnClickProxyListener()));
      setHookedTag(view, R.id.tag_onclick);
</code></pre><p>其中OnClickListenerProxy就是我们要实现的对象，在这里要注意给view设置一个Tag,否则会出现重复代理的情况。<br>下面我们来看看这个代理对象的实现（其实很简单的）：</p>
<pre><code>public class OnClickListenerProxy implements View.OnClickListener {

private static final String TAG = &quot;OnClickListenerProxy&quot;;
private View.OnClickListener onClickListener;
private int MIN_CLICK_DELAY_TIME = 1000;
private long lastClickTime = 0;


private OnListenerProxyCallBack.OnClickProxyListener onClickProxyListener;

public OnClickListenerProxy(View.OnClickListener onClickListener, OnListenerProxyCallBack
        .OnClickProxyListener onClickProxyListener) {
    this.onClickListener = onClickListener;
    this.onClickProxyListener = onClickProxyListener;
}

@Override
public void onClick(final View v) {
    long currentTime = Calendar.getInstance().getTimeInMillis();
    //System.out.println(&quot;--------------&quot; + (currentTime - lastClickTime) + &quot;--------------&quot;);
    if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) {
        lastClickTime = currentTime;
      //  Log.e(&quot;OnClickListenerProxy&quot;, &quot;OnClickListenerProxy&quot;+v.getTag());
        Context context = v.getContext();
        if (context instanceof Activity) {
           // Log.e(&quot;OnClickListenerProxy&quot;, context.getClass().getSimpleName());
        }
        if (null != onClickProxyListener) {//点击代理回调
            onClickProxyListener.onClickProxy(v);
        }
        if (null != onClickListener) {
            onClickListener.onClick(v);
        }
    }
}
}
</code></pre><p>通过Context可以判断Activity的，和获取Activity的具体名称，对于插桩是方便的。<br>同理我们可以实现对于长按事件的监听，甚至于对Listview的Item的点击事件，Recyclerview的Item的点击事件。<br>下面我们来看看Hook的代理的入口：</p>
<pre><code> public void hookStart(Activity activity) {
    if (null != activity) {
        View view = activity.getWindow().getDecorView();
        if (null != view) {
            if (view instanceof ViewGroup) {
                hookStart((ViewGroup) view);
            } else {
                hookOnClickListener(view, false);
                hookOnLongClickListener(view, false);
            }
        }
    }
}
</code></pre><p>这只是一种很简单的情况，但如果像列表控件带滚动的形式，又是另一种处理方式，这是因为Android内部的缓存机制导致的这样的问题。</p>
<pre><code>public void hookStart(ViewGroup viewGroup, boolean isScrollAbsListview) {
    if (viewGroup == null) {
        return;
    }
    int count = viewGroup.getChildCount();
    for (int i = 0; i &lt; count; i++) {
        View view = viewGroup.getChildAt(i);
        if (view instanceof ViewGroup) {//递归查询所有子view
            // 若是布局控件（LinearLayout或RelativeLayout）,继续查询子View
            hookStart((ViewGroup) view, isScrollAbsListview);
        } else {
            hookOnClickListener(view, isScrollAbsListview);
            hookOnLongClickListener(view, isScrollAbsListview);
        }
    }
    hookOnClickListener(viewGroup, isScrollAbsListview);
    hookOnLongClickListener(viewGroup, isScrollAbsListview);
    hookListViewListener(viewGroup);
}
</code></pre><p>必须到递归获取到所有的view控件才可以继续向下运行。</p>
<p>对于在基类里面调用代理呢，肯定是要在view绘制完全的时候，</p>
<pre><code> private boolean isHookListener = false;

@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (isHookListener) {//防止退出的时候还hook
        return;
    }

    getWindow().getDecorView().post(new Runnable() {
        @Override
        public void run() {//等待view都执行完毕之后再hook,否则onLayoutChange执行多次就会hook多次
            HookViewManager.getInstance().hookStart((Activity) mContext);
            isHookListener = true;
        }
    });

}
</code></pre><p>直到这一步才正式的代理了view的相关事件的监听。</p>
<h2 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3.结束语"></a>3.结束语</h2><p>会思考的童鞋会由此思考Hook技术是怎么回事？</p>
<blockquote>
<p>1.Hook英文翻译为“钩子”，而钩子就是在事件传送到终点前截获并监控事件的传输，像个钩子钩上事件一样，并且能够在钩上事件时，处理一些自己特定的事件；<br>2.Hook使它能够将自己的代码“融入”被勾住（Hook）的进程中，成为目标进程的一部分；<br>3.在Andorid沙箱机制下，Hook是我们能通过一个程序改变其他程序某些行为得以实现； </p>
</blockquote>
<p>第一条是不是很熟悉，其实在java层面大部分的Hook都是通过代理实现的，但Hook技术不止包括java层面，还有Native层面，也就是C/C++层面，Android中著名的Hook框架就是——Xposed平台。<br>Hook技术的成功很广泛，只要你像在Android手机上做点黑科技，Hook技术是你必不可少的知识点，包括现在著名的插件化浪潮，也是在其基础上引申拓展的。<br><br>动态代理三部分讲完了，下节将开始我们新的学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前两章想必大家都知道动态代理是怎么回事，本小节的内容是动态代理的实践操作了。在Android项目中如何实现按钮的防双击（防抖动）。&lt;br&gt;这个在Android上又叫Hook技术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 系列（一） 动态代理（上）</title>
    <link href="http://yoursite.com/2017/07/18/dongtaidaili1/"/>
    <id>http://yoursite.com/2017/07/18/dongtaidaili1/</id>
    <published>2017-07-18T05:17:02.000Z</published>
    <updated>2017-07-22T08:59:54.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>想必大家都很耳熟这个模式，或者说这个思想，但实际在项目中用的并不是很多，这节课程我们来详细描述-动态代理是怎么一回事，和使用的范围，以及一定程度的扩展，在Android中的简单实现。</p>
</blockquote>
<h2 id="动态代理的介绍"><a href="#动态代理的介绍" class="headerlink" title="动态代理的介绍"></a>动态代理的介绍</h2><h1 id="1-什么是动态代理"><a href="#1-什么是动态代理" class="headerlink" title="1.什么是动态代理"></a>1.什么是动态代理</h1><ul>
<li>定义：为其他对象提供一种代理以控制对这个对象的访问<br>请注意这个控制，仅代表在这个对象处理之前或之后做某些操作，并不会对这个对象做什么操作，也不会影响这个事务的运行。<br>其中动态代理只是代理模式的一种，代理模式还包括静态代理等。</li>
<li>优缺点：可以实现对于委托类的隐藏，可以对于统一的操作节约代码，实现解耦，但jdk中的proxy只能实现对接口的代理，如果想代理其他的方法等，需要用到第三方的sdk.</li>
<li>使用典范：spring的AOP模式，日志系统，缓存系统等。</li>
<li><p>例图：<br> 1，代理模式<br> <img src="http://oqsn5psbq.bkt.clouddn.com/%E4%BB%A3%E7%90%86.png?attname=&amp;e=1500350970&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:PE21Q_Kc_DgYMOOERQV91i7FrJI" alt="代理模式"></p>
<p> 2，动态代理模式<br> <img src="http://oqsn5psbq.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png?attname=&amp;e=1500350970&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:-PHNRvWxQMQpOTKebKWu1HUBTho" alt=""></p>
</li>
<li><p>我的看法<br>动态代理模式存在的必要：我们在写主业务流程时，经常会遇到一些细枝末节的东西要处理，比如缓存，写日志等，但如果将其直接放在主题代码中，这是对OO的破坏，也会影响整体业务流程的浏览，另一方面会做很多无用功，有人会说：把这种代码抽出来，放在一个基类里面。当然这不失为一种解决方案，但会造成主体代码和枝节代码的耦合加深，会使在模块中依旧添加其他的依赖，而且对于代码移植比较繁琐。<br>所以我们使用动态代理这种思想，降低了代码的耦合程度，也更好的隐藏枝节代码，和保护主体代码。<br>看到这里有人会很疑惑，动态代理怎么和装饰器模式这么类似，我们将会在下节将装饰器模式和动态代理的不同，以及两者的之间的互补。</p>
</li>
</ul>
<h1 id="2-动态代理的实现"><a href="#2-动态代理的实现" class="headerlink" title="2.动态代理的实现"></a>2.动态代理的实现</h1><p>  下面来看一下代码演示（没有使用《Java编程思想》和《设计模式之禅》的代码，详情请参考这两本书）</p>
<p>  1，接口</p>
<pre><code>public interface Subject {
    public void rent();
    public void hello(String str);
}
</code></pre><p>  2，实现类，这个类就是我们的真实对象</p>
<pre><code>public class RealSubject implements Subject {
    @Override
    public void rent() {
        System.out.println(&quot;I want to rent my house&quot;);
    }

    @Override
    public void hello(String str) {
        System.out.println(&quot;hello: &quot; + str);
    }
}
</code></pre><p>  3，要代理的方法</p>
<pre><code>public class DynamicProxy implements InvocationHandler {
//　这个就是我们要代理的真实对象
private Object subject;

//    构造方法，给我们要代理的真实对象赋初值
public DynamicProxy(Object subject) {
    this.subject = subject;
}

@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //　　在代理真实对象前我们可以添加一些自己的操作
    System.out.println(&quot;before rent house&quot;);
    //   真实的方法
    System.out.println(&quot;Method:&quot; + method);

    //    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
    method.invoke(subject, args);

    //　　在代理真实对象后我们也可以添加一些自己的操作
    System.out.println(&quot;after rent house&quot;);

    return null;
}
}
</code></pre><p>4，Client方法</p>
<pre><code>public class Client {

public static void main(String[] args) {
    //    我们要代理的真实对象
    Subject realSubject = new RealSubject();

    //    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的
    InvocationHandler handler = new DynamicProxy(realSubject);

    /*
     * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
     * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象
     * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了
     * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
     */
    Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject
            .getClass().getInterfaces(), handler);

    System.out.println(subject.getClass().getName());
    subject.rent();
    subject.hello(&quot;world&quot;);
}
}
</code></pre><p>  5,总结</p>
<p>动态代理的步骤总结:</p><p><br>1,定义一个接口，并实现这个接口的类，就是实现类，或者称为委托类</p><p><br>2，定义一个代理类，实现jdk的InvocationHandler接口（这个接口在java.lang.reflect包里面，想必大家可以猜到内部怎么实现的吧），主要是将运行时的任务和你准备处理的操作进行搭配。</p><p><br>3,生成代理对象，调用Proxy的方法进行调用，使用。</p>
<p>#3. 结束语</p>
<p>简单的动态代理的代码就是这么多，下节将装饰器模式和动态代理的搭配，通过简单的代码模拟，大家是不是对动态代理已经有所认识，赶快行动起来吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;想必大家都很耳熟这个模式，或者说这个思想，但实际在项目中用的并不是很多，这节课程我们来详细描述-动态代理是怎么一回事，和使用的范围，以及一定程度的扩展，在Android中的简单实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;动态代理的介
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 系列（一） 动态代理（中）</title>
    <link href="http://yoursite.com/2017/07/18/dongtaidaili2/"/>
    <id>http://yoursite.com/2017/07/18/dongtaidaili2/</id>
    <published>2017-07-18T05:17:02.000Z</published>
    <updated>2017-07-22T08:59:45.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>从上节的学习想必大家都知道动态代理怎么写了，现在我们拓展一些，动态代理和装饰器模式，想必大家都很困惑。本小节主要介绍动态代理和装饰器模式的不同以及如何相互搭配。</p>
</blockquote>
<h1 id="1-动态代理和装饰器模式"><a href="#1-动态代理和装饰器模式" class="headerlink" title="1.动态代理和装饰器模式"></a>1.动态代理和装饰器模式</h1><ul>
<li><p>1.装饰器模式的介绍：</p>
<p> 装饰器模式能够实现保持原有的接口，并为新的接口动态的添加功能。装饰器实现了java编程上的一个准则，多组合，少继承。<br><br> 装饰器的一个典型的例子是：java中的IO流的实现,大家在转过头来看javaIO流的思维导图，想必会恍然大悟了。<br><br> 例图：<br></p>
<p> <img src="http://oqsn5psbq.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E5%99%A8.png?attname=&amp;e=1500359908&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:JEwQihnnKKrIwO7F-opjm8QSelQ" alt=""></p>
<p> （ps:这个图会和我们下面将要讲的装饰器模式+动态代理的UML图一致，不再重复显示）</p>
</li>
<li><p>2.两者区别</p>
</li>
</ul>
<p>两者都可以在保持主业务流程下，对对象进行添加方法，增强这个类的使用。<br><br>   但两者有着一些区别：<br><br>   装饰器模式继承了接口，添加了新类，而代理没有对原代码有任何操作。<br><br>   装饰器中的继承和创建新类，会造成出现大量的包装类，对于代码阅读是有困难的。</p>
<h1 id="2-动态代理的装饰器模式搭配"><a href="#2-动态代理的装饰器模式搭配" class="headerlink" title="2.动态代理的装饰器模式搭配"></a>2.动态代理的装饰器模式搭配</h1><p>为什么要这样搭配呢，想必大家在实践过程中使用代理都会遇到的问题–动态代理的扩展性。<br>动态代理是没有办法在源代理类上直接进行拓展的（否则的话全部的接口都会实现拓展的对象），但对于我们来说，并不需要，只是对某些委托类进行操作，这就不太这么方便操作了。所以这时候使用装饰器模式比较好的搭配使用，添加自定义的扩展。<br><br>相对于简单的动态代理，这时候要增加几个新的方法：<br><br>提供动态代理实例的静态工厂类（ProxyFactory）和抽象装饰器（Decorator）<br></p>
<ul>
<li>首次我们看抽象主题接口</li>
</ul>
<pre><code>public interface AbstractSubject {
     void request();
}
</code></pre><ul>
<li>真实主题类（委托类/被代理的对象）</li>
</ul>
<pre><code>public class RealSubject implements AbstractSubject {
public void request() {
    System.out.println(&quot;真实的方法-----RealSubject&apos;s request() ...&quot;);
}
}
</code></pre><ul>
<li>抽象装饰器类（一定要以自己的父类、父接口为一个属性） </li>
</ul>
<pre><code>public class Decorator implements AbstractSubject {
protected AbstractSubject subject = null;

public Decorator(AbstractSubject subject) {
    this.subject = subject;
}

@Override
public void request() {

}
}
</code></pre><ul>
<li>具体装饰器1（根据实际情况，我这里只写三个）</li>
</ul>
<pre><code>public class ConcreteDecorator01 extends Decorator {

public ConcreteDecorator01(AbstractSubject subject) {
    super(subject); //调用父类装饰类的构造器
}

/**
 * 覆盖继承树上的接口中的request()方法，用于装饰原对象
 */
public void request() {
    System.out.println(&quot;第一层装饰 ... 装饰在原主题之前&quot;);
    super.subject.request();
}
}
</code></pre><ul>
<li>具体装饰器2（根据实际情况，我这里只写三个）</li>
</ul>
<pre><code>public class ConcreteDecorator02 extends Decorator {

public ConcreteDecorator02(AbstractSubject subject) {
    super(subject); //调用父类装饰类的构造器
}

/**
 * 覆盖继承树上的接口中的request()方法，用于装饰原对象
 */
public void request() {
    super.subject.request();
    System.out.println(&quot;第二层装饰 ... 装饰在原主题之后&quot;);
}
}
</code></pre><ul>
<li>具体装饰器3（根据实际情况，我这里只写三个）</li>
</ul>
<pre><code>public class ConcreteDecorator03 extends Decorator {

public ConcreteDecorator03(AbstractSubject subject) {
    super(subject); //调用父类装饰类的构造器
}

/**
 * 覆盖继承树上的接口中的request()方法，用于装饰原对象
 */
public void request() {
    super.subject.request();
    System.out.println(&quot;第三层装饰 ... 装饰在原主题之后&quot;);
}
}
</code></pre><ul>
<li>提供动态代理实例的静态工厂类（管理代理实现）</li>
</ul>
<pre><code>public class ProxyFactory {
/**
 * @param realSubject ：指定需要代理的真实主题类的实例
 * @return proxy ：代理的实例
 */
public static AbstractSubject getProxy(AbstractSubject realSubject) {

    // 获得被代理类的类加载器，使得JVM能够加载并找到被代理类的内部结构，以及已实现的interface
    ClassLoader loader = realSubject.getClass().getClassLoader();

    // 获得被代理类已实现的所有接口interface,使得动态代理类的实例
    Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces();

    // 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序
    InvocationHandler handler = new DynamicProxy(realSubject);

    /*
     * 使用java.lang.reflect.Proxy类中的静态方法newProxyInstance()获得代理的实例
     *
     * loader : 被代理类的类加载器 interfaces ：被代理类已实现的所有接口，而这些是动态代理类要实现的接口列表 handler
     * ： 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序
     *
     * return ：返回实现了被代理类所实现的所有接口的Object对象，即动态代理，需要强制转型
     */
    AbstractSubject proxy = (AbstractSubject) Proxy.newProxyInstance(
            loader, interfaces, handler);

    return proxy;
}
}
</code></pre><ul>
<li>代理类</li>
</ul>
<pre><code>public class DynamicProxy implements InvocationHandler {

// 被代理类的实例
Object obj = null;

// 将被代理者的实例传进动态代理类的构造函数中
public DynamicProxy(Object obj) {
    this.obj = obj;
}

/**
 * 覆盖InvocationHandler接口中的invoke()方法
 *
 * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到
 * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊 代码切入的扩展点了。
 */
public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
    /*
     * before ：doSomething();
     */
    System.out.println(&quot;动态代理为真实主题添加一个方法  ...&quot;);
    Object result = method.invoke(this.obj, args);

    /*
     * after : doSomething();
     */
    return result;
}
}
</code></pre><ul>
<li>client</li>
</ul>
<pre><code>public class Client {
public static void main(String[] args) {
    // 被代理类的实例
    AbstractSubject realSubject = new RealSubject();
    // 通过静态工厂获取动态代理的实例
    AbstractSubject proxy = ProxyFactory.getProxy(realSubject);
    // 装饰之前打印出该代理实例的名称
    System.out.println(&quot;装饰前：&quot; + proxy.getClass().getName());
    // 装饰前使用代理实例进行原始操作
    //proxy.request();
    System.out.println(&quot;\n第一次装饰之后的效果如下：&quot;);
    proxy = new ConcreteDecorator01(proxy);
    System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName());
    //proxy.request();

    System.out.println(&quot;\n第二次装饰之后的效果如下：&quot;);
    proxy = new ConcreteDecorator02(proxy);
    System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName());
   // proxy.request();

    System.out.println(&quot;\n第三次装饰之后的效果如下：&quot;);
    proxy = new ConcreteDecorator03(proxy);
    System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName());
    proxy.request();
}
}
</code></pre><ul>
<li><p>总结 </p>
<p> 通过上面的代码描述可以在proxy这个类已经是处理好之后的情况，在后面的大段代码都是标准的装饰器代码。<br><br> 运行之后：<br><img src="http://oqsn5psbq.bkt.clouddn.com/%E4%BB%A3%E7%90%86%E8%A3%85%E9%A5%B0.png?attname=&amp;e=1500367034&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:g_IrjFnUOSlGzblI2M1_mVjL4zw" alt=""><br>看好我画圈的地方，下面将 </p>
<blockquote>
<p>AbstractSubject proxy = ProxyFactory.getProxy(realSubject);</p>
</blockquote>
</li>
</ul>
<p>方法去除，变成一个完整的装饰器模式，看看效果：<br><img src="http://oqsn5psbq.bkt.clouddn.com/=%E8%A3%85%E9%A5%B0%E5%99%A8.png?attname=&amp;e=1500367040&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:W9i0FDPrPHKw0eqlUl5Nr1VncqY" alt=""></p>
<p>可以看到，结果完全相同，只有最初代理的对象不同，一个是经过代理产生的，一个是源接口。<br>对于这样的好处毋庸置疑：代理可以放在其他模块中，对于自定义的功能添加使用装饰器自由组合，对于统一的操作放在代理对象中，这样解耦的形式比较好。</p>
<h1 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3.结束语"></a>3.结束语</h1><p>其实设计模式之前的搭配有很多，只学单独的设计模式的概念并不是很大，很多注明的SDK都是很多设计模式相互搭配而来，请大家多多思考，下节讲动态代理的实际操作–Android中统一处理防双击/抖动。谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从上节的学习想必大家都知道动态代理怎么写了，现在我们拓展一些，动态代理和装饰器模式，想必大家都很困惑。本小节主要介绍动态代理和装饰器模式的不同以及如何相互搭配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-动态代理和装饰器模式&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferencesUtils存储对象</title>
    <link href="http://yoursite.com/2017/07/16/SharedPreferencesUtils/"/>
    <id>http://yoursite.com/2017/07/16/SharedPreferencesUtils/</id>
    <published>2017-07-16T05:42:58.000Z</published>
    <updated>2017-07-22T08:56:17.427Z</updated>
    
    <content type="html"><![CDATA[<p>SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。<br>在我学习优化Utils工具包的一些常见的工具类。<br>在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。<br><a id="more"></a></p>
<ul>
<li><strong>读写基本数据类型</strong></li>
<li><strong>读写Javabean类型</strong></li>
<li><strong>读写List<javabean*>类型</javabean*></strong></li>
<li><strong>读写图片资源</strong></li>
</ul>
<hr>
<h2 id="1-读写基本数据类型"><a href="#1-读写基本数据类型" class="headerlink" title="1,读写基本数据类型"></a>1,读写基本数据类型</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">/**</span></div><div class="line">    * 存储基本数据类型</div><div class="line">    * <span class="doctag">@param</span> context </div><div class="line">    * <span class="doctag">@param</span> key key</div><div class="line">    * <span class="doctag">@param</span> data value</div><div class="line">    */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">(Context context, String key, Object data)</span> </span>&#123;</div><div class="line">       String type = data.getClass().getSimpleName();</div><div class="line">       SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context</div><div class="line">               .MODE_PRIVATE);<span class="comment">//读写基本数据类型都是在一个特定的文件，以软件的包名为文件名</span></div><div class="line">       Editor editor = sharedPreferences.edit();</div><div class="line">       <span class="keyword">if</span> (<span class="string">"Integer"</span>.equals(type)) &#123;<span class="comment">//注意这里是integer对象，同下</span></div><div class="line">           editor.putInt(key, (Integer) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Boolean"</span>.equals(type)) &#123;</div><div class="line">           editor.putBoolean(key, (Boolean) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"String"</span>.equals(type)) &#123;</div><div class="line">           editor.putString(key, (String) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Float"</span>.equals(type)) &#123;</div><div class="line">           editor.putFloat(key, (Float) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Long"</span>.equals(type)) &#123;</div><div class="line">           editor.putLong(key, (Long) data);</div><div class="line">       &#125;</div><div class="line">       editor.commit();</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 读取基本数据类型</div><div class="line">    * <span class="doctag">@param</span> context</div><div class="line">    * <span class="doctag">@param</span> key key</div><div class="line">    * <span class="doctag">@param</span> defValue 当取不到值时返回默认值</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getData</span><span class="params">(Context context, String key, Object defValue)</span> </span>&#123;</div><div class="line">       String type = defValue.getClass().getSimpleName();</div><div class="line">       SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context</div><div class="line">               .MODE_PRIVATE);  <span class="comment">//defValue为为默认值，如果当前获取不到数据就返回它 </span></div><div class="line">       <span class="keyword">if</span> (<span class="string">"Integer"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getInt(key, (Integer) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Boolean"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getBoolean(key, (Boolean) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"String"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getString(key, (String) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Float"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getFloat(key, (Float) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Long"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getLong(key, (Long) defValue);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>将常用到的基本数据类型存入特定的文件中，获取的时候也十分方便快捷。（PS，string不是基本数据类型）</p>
<h2 id="读写Javabean类型"><a href="#读写Javabean类型" class="headerlink" title="读写Javabean类型"></a>读写Javabean类型</h2><p>先期准备<br>Javabean是序列化的，需要继承Serializable接口，实现serialVersionUID。<br>1.判断处理是否是各个数据类型</p>
<pre><code> private static boolean isObject(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; !isSingle(clazz) &amp;&amp; !isArray(clazz) &amp;&amp; !isCollection(clazz) &amp;&amp; !isMap(clazz);
}

private static boolean isSingle(Class&lt;?&gt; clazz) {
    return isBoolean(clazz) || isNumber(clazz) || isString(clazz);
}

public static boolean isBoolean(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (Boolean.TYPE.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz));
}

public static boolean isNumber(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (Byte.TYPE.isAssignableFrom(clazz) || Short.TYPE.isAssignableFrom(clazz) || Integer.TYPE.isAssignableFrom(clazz) || Long.TYPE.isAssignableFrom(clazz) || Float.TYPE.isAssignableFrom(clazz) || Double.TYPE.isAssignableFrom(clazz) || Number.class.isAssignableFrom(clazz));
}

public static boolean isString(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (String.class.isAssignableFrom(clazz) || Character.TYPE.isAssignableFrom(clazz) || Character.class.isAssignableFrom(clazz));
}

public static boolean isArray(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; clazz.isArray();
}

public static boolean isCollection(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; Collection.class.isAssignableFrom(clazz);
}

public static boolean isMap(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; Map.class.isAssignableFrom(clazz);
}
private static boolean isParcelableCreator(Field field) {
    return Modifier.toString(field.getModifiers()).equals(&quot;public static final&quot;) &amp;&amp; &quot;CREATOR&quot;
            .equals(field.getName());
}
</code></pre><p>2,插入数据</p>
<pre><code> public static void setObject(Context context, Object o) {
    Field[] fields = o.getClass().getDeclaredFields();//获取所有声明的属性
    SharedPreferences sp = context.getSharedPreferences(o.getClass().getName(), 0);//将存储的文件名改为Javabean的包名+類名
    SharedPreferences.Editor editor = sp.edit();

    for (int i = 0; i &lt; fields.length; ++i) {
        if (!isParcelableCreator(fields[i])) {
            Class type = fields[i].getType();//类型 class java.lang.class
            String name = fields[i].getName();//名称 id
            Object e;
            if (isSingle(type)) {
                try {
                    if (type != Character.TYPE &amp;&amp; !type.equals(String.class)) {
                        if (!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)) {
                            if (type.equals(Double.TYPE)) {
                                editor.putLong(name, Double.doubleToLongBits(fields[i]
                                        .getDouble(o)));//将double类型的数值存入
                            } else if (type.equals(Float.TYPE)) {
                                editor.putFloat(name, fields[i].getFloat(o));//将float类型的数值存入
                            } else if (type.equals(Long.TYPE) &amp;&amp; !name.equals(&quot;serialVersionUID&quot;)) {
                                editor.putLong(name, fields[i].getLong(o));//将long类型的数值存入
                            } else if (type.equals(Boolean.TYPE)) {
                                editor.putBoolean(name, fields[i].getBoolean(o));//将boolean类型的数值存入
                            }
                        } else {
                            editor.putInt(name, fields[i].getInt(o));//将int类型的数值存入
                        }
                    } else {
                        e = fields[i].get(o);//将string类型的数值存入
                        editor.putString(name, null == e ? null : e.toString());
                    }
                } catch (Exception var14) {
                }
                }else if (isObject(type)) {
                    try {
                        e = fields[i].get(o);
                        if (null != e) {
                            setObject(context, e);
                        } else {
                            try {
                                setObject(context, fields[i].getClass().newInstance());//重新跑一遍
                            } catch (InstantiationException var11) {
                            }
                        }
                    } catch (Exception var12) {

                    }
                } else {
                try {
                    e = fields[i].get(o);
                    //转成json插入
                } catch (IllegalAccessException e1) {
                    e1.printStackTrace();
                }

            }
            }
        }
    editor.apply();
}

public static &lt;T&gt; T getObject(Context context, Class&lt;T&gt; clazz) {
    Object o = null;

    try {
        o = clazz.newInstance();
    } catch (InstantiationException e) {
        e.printStackTrace();
        return (T) o;
    } catch (IllegalAccessException e) {
        e.printStackTrace();
        return (T) o;
    }

    Field[] fields = clazz.getDeclaredFields();
    SharedPreferences sp = context.getSharedPreferences(clazz.getName(), 0);

    for(int i = 0; i &lt; fields.length; ++i) {
        if(!isParcelableCreator(fields[i])) {
            Class type = fields[i].getType();
            String name = fields[i].getName();
            String o_1;
            if(isSingle(type)) {
                try {
                    fields[i].setAccessible(true);
                    if(type != Character.TYPE &amp;&amp; !type.equals(String.class)) {
                        if(!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)){
                            if(type.equals(Double.TYPE)) {
                                fields[i].setDouble(o, Double.longBitsToDouble(sp.getLong(name, 0L)));
                            } else if(type.equals(Float.TYPE)) {
                                fields[i].setFloat(o, sp.getFloat(name, 0.0F));
                            } else if(type.equals(Long.TYPE)) {
                                fields[i].setLong(o, sp.getLong(name, 0L));
                            } else if(type.equals(Boolean.TYPE)) {
                                fields[i].setBoolean(o, sp.getBoolean(name, false));
                            }
                        } else {
                            fields[i].setInt(o, sp.getInt(name, 0));
                        }
                    } else {
                        o_1 = sp.getString(name, (String)null);
                        if(null != o_1) {
                            fields[i].set(o, o_1);
                        }
                    }
                } catch (Exception e) {

                }
            } else if(isObject(type)) {
                Object tempValue = getObject(context, fields[i].getType());
                if(null != tempValue) {
                    fields[i].setAccessible(true);

                    try {
                        fields[i].set(o, tempValue);
                    } catch (Exception e) {

                    } 
                }
            } else {
                //json数据解析
            }
        }
    }

    return (T) o;
}
</code></pre><p>主要的思想就是遍历javabean所有的属性对象，取出，按照类型一个个的存入XML文件中。<br>取出时也是同时转成了存入的形式，很方便利</p>
<h2 id="读写List-lt-Javabean-gt"><a href="#读写List-lt-Javabean-gt" class="headerlink" title="读写List&lt;Javabean&gt;"></a>读写List&lt;<em>Javabean</em>&gt;</h2><p>对于list&lt;<em>javabean</em>&gt;，不太适合用上面的方法，一般来说不太会存这种数据，数据量比较大。如果有这个需求，可以把list&lt;<em>javabean</em>&gt;转成json形式，然后存入xml文件中。关于Javabean数据转成json会在另一篇叙述。</p>
<h2 id="读写图片资源"><a href="#读写图片资源" class="headerlink" title="读写图片资源"></a>读写图片资源</h2><p>所谓的读写图片，个人感觉用处不大，先说一下思路。其实也很简单，就是通过base64将输出流转成string。<br>代码奉上：</p>
<pre><code> private void saveBitmapToSharedPreferences(Context context,String key,Bitmap bitmap){  
    //第一步:将Bitmap压缩至字节数组输出流ByteArrayOutputStream  
    ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();  
    bitmap.compress(CompressFormat.PNG, 80, byteArrayOutputStream);  
    //第二步:利用Base64将字节数组输出流中的数据转换成字符串String  
    byte[] byteArray=byteArrayOutputStream.toByteArray();  
    String imageString=new String(Base64.encodeToString(byteArray, Base64.DEFAULT));  
    //第三步:将String保持至SharedPreferences  
    SharedPreferences sharedPreferences=context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);  
    Editor editor=sharedPreferences.edit();  
    editor.putString(key, imageString);  
    editor.commit();  
}  

private Bitmap getBitmapFromSharedPreferences(Context context, String key, Object defValue){  
    SharedPreferences sharedPreferences=getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);  
    //第一步:取出字符串形式的Bitmap  
    String imageString=context.sharedPreferences.getString(key,defValue);  
    //第二步:利用Base64将字符串转换为ByteArrayInputStream  
    byte[] byteArray=Base64.decode(imageString, Base64.DEFAULT);  
    ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(byteArray);  
    //第三步:利用ByteArrayInputStream生成Bitmap  
    Bitmap bitmap=BitmapFactory.decodeStream(byteArrayInputStream);  
    return bitmap; 
}  
</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>简单叙述了下SharedPreferences的使用，毕竟作为Android中几个主要的存储数据的方式，熟练掌握还是 非常有必要的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。&lt;br&gt;在我学习优化Utils工具包的一些常见的工具类。&lt;br&gt;在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>EventBus翻译</title>
    <link href="http://yoursite.com/2017/07/16/eventBus/"/>
    <id>http://yoursite.com/2017/07/16/eventBus/</id>
    <published>2017-07-16T05:42:58.000Z</published>
    <updated>2017-07-22T09:00:22.881Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是RxBus的权威文章的翻译,<a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">原文</a>，也算是写Retrofit+RxJava学习的开端 ，在以后的博客中会陆续介绍这种框架使用的好处（可能不会连续发布）。<br>这篇文章有三个部分：</p>
<ul>
<li>1.事件总线快速入门</li>
<li>2.用RxJava实现事件总线</li>
<li>3.这种方法的离别思念</li>
</ul>
<p>“RxBus”将不会成为一个库。实现事件总线RxJava是如此容易以至于它不能作为一个独立的库。</p>
<h2 id="第1部分：什么是事件总线？"><a href="#第1部分：什么是事件总线？" class="headerlink" title="第1部分：什么是事件总线？"></a>第1部分：什么是事件总线？</h2><p>让我们来谈谈两个似乎相似的概念：观察者模式和发布 - 订阅模式。<br>观察者模式<br>这是一个发展模式，借助此，你的类或主对象（被称为可观察者）利用相关信息（事件）通知其他感兴趣的类或对象（称为观察者）。<br>发布 - 订阅模式<br>发布 - 订阅模式的目标和观察者模式的目标是完全一样的，即你想要一些其他的类来了解正在发生的某些事件。<br>尽管如此，观察者模式和发布 - 订阅模式之间存在一个重要的语义差别：发布 - 订阅模式的重点是外界“广播”的消息。观察者并不关注事件传给谁，而只关注事件是否已经传出。换句话说，观察者（发布者）并不关注谁是观察员（订阅者）。<br>为什么匿名？<br>它允许这个东西叫做“脱钩”，这是计算机编程具有良好的口碑。在设计中，你想尽可能的保持低耦合。<br>通常情况下，你会期望发布者对每个它需要通知的用户有直接的了解，所以当事件或消息已准备就绪时，它可以去通知他们每个人。但随着事件的总线的出现，发布者被解除该任务，并且这种独立性有所帮助，因为发布者和订阅者不必有建立两者之间相关性的逻辑代码。<br>换句话说“自觉低耦论”是你的代码在书写时就应该所思考的，这是程序员应该有的水平。<br>如何匿名？<br>在发布 - 订阅模式中一个很自然的问题是：你如何真正地实现发布者和订阅者之间的匿名？一个简单的方法是得到一个中间人，让那个中间人负责所有的通信。而事件总线就是这样的一个中间人。<br>事件总线就是这么简单。<br>常用于Android的使用的两个事件总线库是otto和EventBus。网上有大量的帖子解释如何在你的手机应用程序中实现它们。</p>
<h2 id="第2部分：用总线RxJava实现事件（？？是“在”还是“用”）"><a href="#第2部分：用总线RxJava实现事件（？？是“在”还是“用”）" class="headerlink" title="第2部分：用总线RxJava实现事件（？？是“在”还是“用”）"></a>第2部分：用总线RxJava实现事件（？？是“在”还是“用”）</h2><p>我已经将使用Android上RxJava的显示世界的例子粘贴在这个GitHub库上，所以我会坚持展示其完整的实现方式。下面是执行的部分代码：</p>
<pre><code>// this is the middleman object
public class RxBus {

private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create());
  public void send(Object o) {
        _bus.onNext(o);
  }

  public Observable&lt;Object&gt; toObserverable() {
    return _bus;
  }
}
</code></pre><p>你现在有一个事件总线可以使用了。<br>这是你如何将事件发布到总线：</p>
<pre><code>@OnClick(R.id.btn_demo_rxbus_tap)
public void onTapButtonClicked() {

_rxBus.send(new TapEvent());
}
</code></pre><p>这是你如何倾听来自其他片段/服务等。</p>
<pre><code>_rxBus.toObserverable()
.subscribe(new Action1&lt;Object&gt;() {
  @Override
  public void call(Object event) {

    if(event instanceof TapEvent) {
      _showTapText();

    }else if(event instanceof SomeOtherEvent) {
      _doSomethingElse();
    }
  }
});
</code></pre><p>在这个例子中，我们后从顶部片段（绿色部分）的事件，并从底部片段（蓝色部分）中（通过总线）收听。<br>在下面这个例子中，我们从顶部片段（绿色方）发布事件，并从底部片段（蓝色部分）收听（通过事件总线）。</p>
<h2 id="第3部分-离别的思念"><a href="#第3部分-离别的思念" class="headerlink" title="第3部分 - 离别的思念"></a>第3部分 - 离别的思念</h2><p>死亡事件</p>
<p>在一些情况下，知道是否有观察者监听当前总线是非常有用的。比如，如果你使用事件总线来处理你的GCM推送通知），如果应用程序是在前台 ，此时你不希望发送推送通知，这时，监听“死亡事件”是非常重要的。<br>例如，在不久前发布的婚礼派对，我们增加了“信息”到我们的应用程序。如果用户的应用程序开启（因而具有至少一个或更多的听众到总线），我们不会发送推送通知，但如果他们的应用程序在后台，那么我们发送推送通知，让他们知道聊天信息。当一个事件被发布到事件总线后，如果没有用户在听，会返回一个死亡事件。如果我们得到一个死亡事件，推送通知的将被发送出去。<br>你将怎样利用RxBus来实现呢？</p>
<p>事实上，这很容易。受试者有一个有用的方法hasObservers，这将准确的告诉我们实现方式。这被添加RxJava的1.x release 中，所以你必须要安装RxAndroid的最新版本才能看到这种方法（0.23.0）。<br>如果你只是想在Andr​​oid应用程序中使用事件总线，你可能最好使用otto（强烈推荐）或EventBus库 。Otto有一个由注解推动的干净的API，可能更为简单易用。</p>
<p>虽然这篇文章写得很好，翻译的不好，以下的博客将会介绍EventBus的一般使用和RXJava及RxBus的使用。<br><a href="http://blog.csdn.net/u012930328/article/details/51993346" target="_blank" rel="external">Csdn原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是RxBus的权威文章的翻译,&lt;a href=&quot;http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/&quot; target=&quot;_blank
    
    </summary>
    
      <category term="page" scheme="http://yoursite.com/categories/page/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>仿Big-Bang实现</title>
    <link href="http://yoursite.com/2016/10/24/bigbang1/"/>
    <id>http://yoursite.com/2016/10/24/bigbang1/</id>
    <published>2016-10-24T09:57:02.000Z</published>
    <updated>2017-07-22T08:58:31.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://blog.csdn.net/u012930328/article/details/52913912" target="_blank" rel="external">原文地址</a><br><br>前几天去看了锤子的发布会，没想到这次还是诚意满满。作为程序员，就关注了在本次发布会出现的两大创意（其实只能算得上微创新）。第一个就是本次要说的big-bang，另一个是One Step。</p>
</blockquote>
<p>先简要介绍一下One Step，毕竟本次的主题不是他。在Android中其实已经有了相关的介绍，不知道各位基友注意到没有。早在API11的时候官方推出一个新的API—Drag and Drop。<a href="https://developer.android.com/guide/topics/ui/drag-drop.html" target="_blank" rel="external">官方链接</a>。<br>无法科学上网的童鞋们只能通过下图（截取了整个界面）来看这个功能的实现。<br><a href="http://pan.baidu.com/s/1c155YaG" target="_blank" rel="external">图片下载，图片太大了</a><br>详情请看—链接<a href="https://zhuanlan.zhihu.com/p/23066211" target="_blank" rel="external">大神的解析</a></p>
<p>下面来进入BigBang的学习过程，通过发布会上简简单单的演示，我们可以看到一共有三步，系统级拦截长触摸事件+系统剪切板+分词技术。这三个技术现在都比较成熟，不要担心。如果想实现系统级的拦截可以使用Xposed技术，用来拦截,在这里不做赘述。<br>现在主要分为两部分讲实现BigBang技术的实现。</p>
<p> <strong>1. 实现基本功能</strong></p>
<blockquote>
<p>本部分主要介绍系统剪切板，中文/英文分词的实现和问题的解决</p>
</blockquote>
<p><strong>1，使用系统剪切板</strong><br><br>            首先启动一个服务，在其他软件上使用剪切板时可以监控通知软件有新的内容出现，并在通知栏上进行提示用户操作。<br><br>        ClipServer.java（其他方法暂不赘述）</p>
<pre><code> @Override
public int onStartCommand(Intent intent, int flags, int startId) {
    final ClipboardManager clipboardManager = (ClipboardManager) getSystemService
            (CLIPBOARD_SERVICE);
    clipboardManager.addPrimaryClipChangedListener(() -&gt; {
        if (clipboardManager.hasPrimaryClip()) {
            if (clipboardManager.getPrimaryClipDescription().hasMimeType(
                    ClipDescription.MIMETYPE_TEXT_PLAIN)) {
                ClipData primaryClip = clipboardManager.getPrimaryClip();
                if (primaryClip != null) {
                    ClipData.Item item = primaryClip.getItemAt(0);
                    if (item != null &amp;&amp; !TextUtils.isEmpty(item.getText().toString())) {
                        startNofi(item.getText().toString());
                    }
                }
            }
        }
    });
    return super.onStartCommand(intent, flags, startId);
}
 private void startNofi(String s) {
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    Intent resultIntent = new Intent(this, ReceiverClip.class);
    resultIntent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    resultIntent.putExtra(ReceiverClip.EXTRA_TEXT, s);
    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, resultIntent,
            PendingIntent.FLAG_UPDATE_CURRENT);
    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher);
    notifyBuilder = new NotificationCompat.Builder(this)
            .setLargeIcon(bitmap)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentTitle(getResources().getText(R.string.nofi_tongzhi))
            .setContentText(getResources().getText(R.string.nofi_context))
            .setWhen(System.currentTimeMillis())
            .setTicker(&quot;Big bang&quot;)
            .setOngoing(true)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent);
    manager.notify(121, notifyBuilder.build());
}
</code></pre><p>在MainActivity上进行启动服务，在这里童鞋们可以添加一些（XX）的技术，尽量使这个服务线程保活。比如双进程守护（像NDK双进程守护），系统的辅助服务，相互唤醒（全家桶），悬浮窗1px等等（这样的技术在此不做描述，毕竟国内的环境，，，，）。</p>
<p>MainActivity.java</p>
<pre><code> private void initData() {
    Intent intent = new Intent(MainActivity.this, ClipServer.class);
    startService(intent);
}
</code></pre><p>   系统剪切板就是这点内容，下面是是分词技术。<br><br>   <strong>2.中文/英文分词技术</strong><br><br>      通过百度/谷歌查询可知分词是比较成熟的，像Word分词器，IKAnalyzer分词器等等，使用Java实现的分词器（知名的）十多个。<br>      在本文中主要使用的是IKAnalyzer+Lucene（本地）。做过功课的童鞋们大概也看出来分词器需要web端实现或添加大字典。本人猜测锤子的分词是在服务端实现的，毕竟本地实现分词不仅需要大字典还有运算时的高耗，在本地实现运算一段100字左右的段落，会占用大约2s-3s的时间（我的渣渣手机），同时还有IKAnalyzer.cfg.xml，ext_stopword.dic两个文件，作为字典，配置文件。<br>      言归正传，我用的是IKAnalyzer-2012_u3(好像不更新了)，和Lucene的三个包，lucene-analyzers-3.1.0.jar，lucene-core-3.6.0.jar，lucene-highlighter-3.6.0-sources.jar。在Maven仓库里面没有Lucene的三个包（有点老），大家在官网上下，或者在本文最后提供的地址中去爬。<br>      使用jdk1.8的童鞋们在build.gradle中添加</p>
<pre><code> compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
</code></pre><p>在解析界面，使用代码：</p>
<pre><code>String text = getIntent().getStringExtra(EXTRA_TEXT);
    if (!TextUtils.isEmpty(text)) {
        List&lt;String&gt; keywordList = new ArrayList&lt;&gt;();
        try {
            byte[] bt = text.getBytes();
            InputStream ip = new ByteArrayInputStream(bt);
            Reader read = new InputStreamReader(ip);
            IKSegmenter iks = new IKSegmenter(read, true);//true开启只能分词模式，如果不设置默认为false，也就是细粒度分割
            Lexeme t;
            while ((t = iks.next()) != null) {
                keywordList.add(t.getLexemeText());
                mLayout.addTextItem(t.getLexemeText());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre><p>就是这么短的代码量，是不是很惊喜，如此简单的实现。<br>好了，现在实现界面。<br><br> <strong>3，分词界面</strong><br><br>    主要就是一个流式布局，TouchEvent事件。在触摸一个词时加入StringBuilder中。下面放出一个大神写的仿锤子布局（本人实力不够，，，，）。<br><br>    BigBangLayout.java</p>
<pre><code> @Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

    int widthSize = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
    int contentWidthSize = widthSize - mActionBar.getContentPadding();
    int heightSize = 0;

    int childCount = getChildCount();

    int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);

    mLines = new ArrayList&lt;&gt;();
    Line currentLine = null;
    int currentLineWidth = contentWidthSize;
    for (int i = 0; i &lt; childCount; i++) {

        View child = getChildAt(i);

        if (mActionBar == child) {
            continue;
        }

        child.measure(measureSpec, measureSpec);

        if (currentLineWidth &gt; 0) {
            currentLineWidth += mItemSpace;
        }
        currentLineWidth += child.getMeasuredWidth();
        if (mLines.size() == 0 || currentLineWidth &gt; contentWidthSize) {
            heightSize += child.getMeasuredHeight();
            currentLineWidth = child.getMeasuredWidth();
            currentLine = new Line(mLines.size());
            mLines.add(currentLine);
        }
        Item item = new Item(currentLine);
        item.view = child;
        item.index = i;
        item.width = child.getMeasuredWidth();
        item.height = child.getMeasuredHeight();
        currentLine.addItem(item);
    }

    Line firstSelectedLine = findFirstSelectedLine();
    Line lastSelectedLine = findLastSelectedLine();
    if (firstSelectedLine != null &amp;&amp; lastSelectedLine != null) {
        int selectedLineHeight = (lastSelectedLine.index - firstSelectedLine.index + 1) * (firstSelectedLine.getHeight() + mLineSpace);
        mActionBar.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(selectedLineHeight, MeasureSpec.UNSPECIFIED));
    }

    int size = heightSize + getPaddingTop() + getPaddingBottom() + (mLines.size() - 1) * mLineSpace + mActionBarTopHeight + mActionBarBottomHeight;
    super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(size, MeasureSpec.EXACTLY));
}

@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int top;
    int left;
    int offsetTop;

    Line lastSelectedLine = findLastSelectedLine();
    Line firstSelectedLine = findFirstSelectedLine();

    for (int i = 0; i &lt; mLines.size(); i++) {
        Line line = mLines.get(i);
        List&lt;Item&gt; items = line.getItems();
        left = getPaddingLeft() + mActionBar.getContentPadding();

        if (firstSelectedLine != null &amp;&amp; firstSelectedLine.index &gt; line.index) {
            offsetTop = -mActionBarTopHeight;
        } else if (lastSelectedLine != null &amp;&amp; lastSelectedLine.index &lt; line.index) {
            offsetTop = mActionBarBottomHeight;
        } else {
            offsetTop = 0;
        }

        for (int j = 0; j &lt; items.size(); j++) {
            Item item = items.get(j);
            top = getPaddingTop() + i * (item.height + mLineSpace) + offsetTop + mActionBarTopHeight;
            View child = item.view;
            int oldTop = child.getTop();
            child.layout(left, top, left + child.getMeasuredWidth(), top + child.getMeasuredHeight());
            if (oldTop != top) {
                int translationY = oldTop - top;
                child.setTranslationY(translationY);
                child.animate().translationYBy(-translationY).setDuration(200).start();
            }
            left += child.getMeasuredWidth() + mItemSpace;
        }
    }

    if (firstSelectedLine != null &amp;&amp; lastSelectedLine != null) {
        mActionBar.setVisibility(View.VISIBLE);
        mActionBar.setAlpha(1);
        int oldTop = mActionBar.getTop();
        int actionBarTop = firstSelectedLine.index * (firstSelectedLine.getHeight() + mLineSpace) + getPaddingTop();
        mActionBar.layout(getPaddingLeft(), actionBarTop, getPaddingLeft() + mActionBar.getMeasuredWidth(), actionBarTop + mActionBar.getMeasuredHeight());
        if (oldTop != actionBarTop) {
            int translationY = oldTop - actionBarTop;
            mActionBar.setTranslationY(translationY);
            mActionBar.animate().translationYBy(-translationY).setDuration(200).start();
        }
    } else {
        if (mActionBar.getVisibility() == View.VISIBLE){
            mActionBar.animate().alpha(0).setDuration(200).setListener(mActionBarAnimationListener).start();
        }
    }
}
</code></pre><p>还有上面的几个按钮在BigBangActionBar.java</p>
<pre><code> private void initSubViews() {
    Context context = getContext();

    mBorder = ContextCompat.getDrawable(context, R.drawable.bigbang_action_bar_bg);
    mBorder.setCallback(this);

    mSearch = new ImageView(context);
    mSearch.setImageResource(R.mipmap.bigbang_action_search);
    mSearch.setOnClickListener(this);
    mShare = new ImageView(context);
    mShare.setImageResource(R.mipmap.bigbang_action_share);
    mShare.setOnClickListener(this);
    mCopy = new ImageView(context);
    mCopy.setImageResource(R.mipmap.bigbang_action_copy);
    mCopy.setOnClickListener(this);

    addView(mSearch, createLayoutParams());
    addView(mShare, createLayoutParams());
    addView(mCopy, createLayoutParams());

    setWillNotDraw(false);

    mActionGap = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 15, getResources().getDisplayMetrics());
    mContentPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, getResources().getDisplayMetrics());
}
 @Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int childCount = getChildCount();
    int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    for (int i = 0; i &lt; childCount; i++) {
        View child = getChildAt(i);
        child.measure(measureSpec, measureSpec);
    }

    int width = MeasureSpec.getSize(widthMeasureSpec);
    int height = MeasureSpec.getSize(heightMeasureSpec);

    setMeasuredDimension(width, height + mContentPadding + mSearch.getMeasuredHeight());
}

@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int width = getMeasuredWidth();
    int height = getMeasuredHeight();

    layoutSubView(mSearch, mActionGap, 0);
    layoutSubView(mShare, width - mActionGap * 2 - mShare.getMeasuredWidth() - mCopy.getMeasuredWidth(), 0);
    layoutSubView(mCopy, width - mActionGap - mCopy.getMeasuredWidth(), 0);

    Rect oldBounds = mBorder.getBounds();
    Rect newBounds = new Rect(0, mSearch.getMeasuredHeight() / 2, width, height);

    if (!oldBounds.equals(newBounds)) {
        ObjectAnimator.ofObject(mBorder, &quot;bounds&quot;, new RectEvaluator(), oldBounds, newBounds).setDuration(200).start();
    }
}
</code></pre><p>至此大家可以看看实现。一般来说剪切板需要保存历史记录，下面开始实现数据库。喜欢使用原生数据库的实现，下节可以不用看了，在本文中数据库使用GreenDao实现数据库操作。<br>相信大家肯定接触过，下面只是简单的介绍一下。<br><br> <strong>3. 添加数据库等使用技术</strong><br><br>    在main下面建立java-gen(大家都这样写，其实无所谓)，在build.gradle中设置</p>
<pre><code> sourceSets{
    main{
        java.srcDirs=[&apos;src/main/java&apos;,&apos;src/main/java-gen&apos;]
    }
}
</code></pre><p>还有一个 compile ‘de.greenrobot:greendao:1.3.7’，将greendao的包导进去。<br>接下来开始建立依赖库，在依赖库的build.gradle写：</p>
<pre><code>apply plugin: &apos;java&apos;

dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    compile &apos;de.greenrobot:greendao-generator:1.3.1&apos;
}

sourceCompatibility = &quot;1.8&quot;
targetCompatibility = &quot;1.8&quot;
</code></pre><p>在java文件中写</p>
<pre><code> public static void main(String[] args) throws Exception {
    // 正如你所见的，你创建了一个用于添加实体（Entity）的模式（Schema）对象。
    // 两个参数分别代表：数据库版本号与自动生成代码的包路径。
    Schema schema = new Schema(1, &quot;com.longshihan.sqlite&quot;);
    //      当然，如果你愿意，你也可以分别指定生成的 Bean 与 DAO 类所在的目录，只要如下所示：
    //      Schema schema = new Schema(1, &quot;me.itangqi.bean&quot;);
    //      schema.setDefaultJavaPackageDao(&quot;me.itangqi.dao&quot;);

    // 模式（Schema）同时也拥有两个默认的 flags，分别用来标示 entity 是否是 activie 以及是否使用 keep sections。
    // schema2.enableActiveEntitiesByDefault();
    // schema2.enableKeepSectionsByDefault();

    // 一旦你拥有了一个 Schema 对象后，你便可以使用它添加实体（Entities）了。
    addNote(schema);

    // 最后我们将使用 DAOGenerator 类的 generateAll() 方法自动生成代码，此处你需要根据自己的情况更改输出目录（既之前创建的 java-gen)。
    // 其实，输出目录的路径可以在 build.gradle 中设置，有兴趣的朋友可以自行搜索，这里就不再详解。
    new DaoGenerator().generateAll(schema, &quot;D:\\1\\BigBang1\\app\\src\\main\\java-gen&quot;);
}

/**
 * @param schema
 */
private static void addNote(Schema schema) {
    // 一个实体（类）就关联到数据库中的一张表，此处表名为「Note」（既类名）
    Entity note = schema.addEntity(&quot;Clip&quot;);
    // 你也可以重新给表命名
    // note.setTableName(&quot;NODE&quot;);

    // greenDAO 会自动根据实体类的属性值来创建表字段，并赋予默认值
    // 接下来你便可以设置表中的字段：
    note.addIdProperty();
    note.addStringProperty(&quot;text&quot;).notNull();
    // 与在 Java 中使用驼峰命名法不同，默认数据库中的命名是使用大写和下划线来分割单词的。
    // For example, a property called “creationDate” will become a database column “CREATION_DATE”.
    note.addStringProperty(&quot;comment&quot;);
    note.addDateProperty(&quot;date&quot;);
}
</code></pre><p>这个全凭自己的需求。建立表等，这种方法比较简单，但适合扩展，或者使用注解的方式生成。<br>运行或在java-gen中生成表名的类Clip，ClipDao，DaoMaster和DaoSession这三个。<br>新建一个DaoManager,来管理ClipDao。或者在Application 中实现也可。<br>所以在服务中就可以添加信息。</p>
<pre><code>String comment = primaryClip.getDescription().toString();
                       Clip note = new Clip(null, item.getText().toString(), comment, new Date());
                       App.getInstance().App_session().getClipDao().insert(note);
</code></pre><p>在MainActivity 可以使用RecyclerView 列表。将数据库中所有数据取出，显示在界面中。</p>
<p>效果图：<br>         <img src="http://img.blog.csdn.net/20161025100944293" alt="这里写图片描述"></p>
<p>以上这些就是全部内容，附上我的github地址：<a href="https://github.com/longshihan1/Big_Bang" target="_blank" rel="external">链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u012930328/article/details/52913912&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&lt;br&gt;前几天去看了锤子的发
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>关于学习RN和微信小程序一个月随感</title>
    <link href="http://yoursite.com/2016/10/14/rn1/"/>
    <id>http://yoursite.com/2016/10/14/rn1/</id>
    <published>2016-10-14T13:20:02.000Z</published>
    <updated>2017-07-22T08:00:55.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2016.10-11.14是我学习（业余时间）RN和微信小程序一个月了，学了一些控件和事件。现在在这里做一下整理和总结。</p>
</blockquote>
<h2 id="一、React-Native的实现和相关问题的解决"><a href="#一、React-Native的实现和相关问题的解决" class="headerlink" title="一、React Native的实现和相关问题的解决"></a>一、React Native的实现和相关问题的解决</h2><ol>
<li>React Native的安装</li>
</ol>
<blockquote>
<p>React Native 是FaceBook去年推出的移动端通用代码的一套解决方案。总得来说，在目前为止是比较完善的。但官方的一些Demo是向IOS开发的，Android平台运行时比较麻烦的。<a href="https://github.com/facebook/react-native" target="_blank" rel="external">Github地址</a>，官方有专门的人进行维护，而且更新的速度很快。Demo也在里面。</p>
</blockquote>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先提到React Native，肯定首先提到JSX语法，是一种构造虚拟的DOM结构体,这是FaceBook团队开发。JSX可以把Html的标签直接编写JavaScript对象，使用的是Xml-like语法，这种语法需要通过JSXTransformer翻译成真实可用的JavaScript代码。既然JSX是语法，肯定有其遵循的一套书写方案。在这里就不做赘述，需要了解的可以去百度。<br>   在这里说一下需要注意的几点，否则在运行时会报错。</p>
<pre><code> 1. React Native在导入其他模块时，在Component里面使用的对象的首字母大写。
 2. JSX只能执行一次运行结束的JavaScript语句（不清楚这样表述正不正确），所以像ifelse这样的无法执行。
 3. JSX只能执行一个代码块，就是只能存在一个根节点。
 4. 相关JSX的关键字和HTML的关键字冲突
注意以上四点就可以避开很多的坑。
</code></pre><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，React Native运行的是ES6(或者兼容前代)的执行标准，如果小伙伴不了解ES6可以先去看相关的视频、书籍，毕竟ES6是下一代JavaScript的标准，与现阶段使用的JavaScript还是有不少区别的。<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  好了，介绍完前提的技术，现在可以进行React Native的Window下的安装了。<br>       1，安装JDK,SDK，并写入环境变量中，安装git，Python（非必须，但这貌似是开发者的标配了）<br>       2，官网上安装Node.js,<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>，配置环境变量<br>       3，安装react-native命令行工具，npm install -g react-native-cli</p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK，其实就这两步，然后就可以在相关的文件夹中进行生产代码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native init MyProject</div></pre></td></tr></table></figure>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要等大约半个小时，，，网络好的话，小伙伴还可以使用代理，请百度。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载完成后在控制台会出现”react native android ”字样。这就说明下载成功。<br>目录：<br><img src="http://img.blog.csdn.net/20161114161439853" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出React Native 支持Android和IOS的操作，我们的操作的入口就是index.android.js，而IOS同理。</p>
<ol>
<li>React Native的运行<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到了这个步骤，说明已经下载成功，上方的步骤已经完成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   那么现在可以打开两个软件：Android Studio和Webstorm(使用Viual Studio Code也可)。<br>  将Android项目（上图的android文件夹）导入到Android Studio中，最终图：<br>  <img src="http://img.blog.csdn.net/20161114171336635" alt="这里写图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   在build.gradle中可以看出引用了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &quot;com.facebook.react:react-native:+&quot;  // From node_modules</div></pre></td></tr></table></figure>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个maven中有<br><img src="http://img.blog.csdn.net/20161114171533857" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK系列的网络请求框架，加载图片的fresco,还有支持react的jar文件。希望童鞋在使用添加ReactNative的时候勿要出现重复引用，模块重合。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将整个文件夹导入Webstorm中，目录结构：<br><img src="http://img.blog.csdn.net/20161114171845393" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里还要设置js的解析方式和运行方式，<br><img src="http://img.blog.csdn.net/20161114172029857" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意command设置为Start，就可以了。<br><img src="http://img.blog.csdn.net/20161114172410993" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里要设置为JSX，才可以解析。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你以为到这里就可以运行了？NO，工欲善其事必先利其器，我们还是先导入一个ReactNative的模板吧。<br><a href="https://github.com/virtoolswebplayer/ReactNative-LiveTemplate" target="_blank" rel="external">Github链接</a><br>直接下载下来，导入里面的ReactNative.jar文件就可以了，是WebStorm里面的Import Settings…..<br>接下来我们就可以愉快的玩耍了。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将Android项目跑到手机上，（如果Gradle出现问题，检查下版本，是不是高于23.0.1，还有gradle的版本不要太新，我是1.3.1正常编译。现阶段的兼容性还是有问题的，出现问题的小伙伴可以在下方留言）<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后WebStorm可以直接运行，在控制台可以看到npm start就说明已经在启动了。<br>看到React packager ready.就说明已经跑起来了，在浏览器中打开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8081/index.android.bundle?platform=android</div></pre></td></tr></table></figure>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果出现如下图的信息就说明正常启动，下一步就是修改软件的局域网地址。<br><img src="http://img.blog.csdn.net/20161114181756164" alt="这里写图片描述"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果网速不好，可以修改这里的设置网络延时时间，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const MAX_WAIT_TIME = 120000;</div></pre></td></tr></table></figure>
<p>文件在<br><img src="http://img.blog.csdn.net/20161114175456702" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个文件曾经改变过位置，直接百度的话，可能找不到路径，以最新的路径为准。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果小伙伴的手机是小米手机，请在开发者选项里面将miui优化关闭，然后重启一下就可以了，软件刚安装有一个选项是在其他应用的上层显示，请选中。这样才能进入界面。</p>
<blockquote>
<p>PS:如果现在才使用ReactNative的童鞋会发现，在init项目的时候会安装yarn，，，倒霉的npm管理器的迭代会直接影响我们构建的速度，没有办法，只好在npm中装在装一个yarn,安装方式相同，npm install -g yarn，（-g是全局安装，会直接安装在AppData/npm中），重新构建 项目的时候会发现明显快了不少。</p>
</blockquote>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件刚进入一般都是红底黑字，这是ReactNative 的错误界面（就是这个特色）。<br><img src="http://img.blog.csdn.net/20161115111715705" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开Dev setting 设置电脑的IP和端口（比如192.168.0.100：8081等），前提必须在一个局域网中，重新reload一下，就可以看到界面。<br> <img src="http://img.blog.csdn.net/20161115111824111" alt="这里写图片描述"><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是错误的界面（ps:局域网链接失败，可以cmd打开控制台输入ipconfig查看当前的局域网ip）<br><img src="http://img.blog.csdn.net/20161115111802119" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们会发现这个界面上的文字与index.android.js上书写的文字雷同，我们改变index.android.js上的文字，重新reload会发现界面也随之变化。我们可以得出一个结论，这个文件就是ReactNative的入口文件。<br> <img src="http://img.blog.csdn.net/20161115111956971" alt="这里写图片描述"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此，ReactNative的运行已经实现。</p>
<h1 id="3-React-Native与原生的调用"><a href="#3-React-Native与原生的调用" class="headerlink" title="3. React Native与原生的调用"></a>3. React Native与原生的调用<br></h1><p>  现在React Native已经可以跑起来了。大家可以愉快的玩耍了。上图就是界面布局，下图就是布局样式：<br>  <img src="http://img.blog.csdn.net/20161115112151422" alt="这里写图片描述"><br>  <br>React Native遵循Flex布局方式，详情请看<a href="http://reactnative.cn/docs/0.37/getting-started.html" target="_blank" rel="external">官方文档</a><br>  对于一些控件的使用，可以参考官方文档，在这里需要注意一下，对于Android来说，官方文档可能更新有些慢，有一些被放弃的属性在官方文档上依然有体现。请注意Image控件，对于Android目录下mipmap和drawable目录下的图片必须保证正确引用，引用方式：</p>
<p>&gt;<br>&gt;</p>
<blockquote>
<pre><code>&lt;image source={{uri:XXXX}}/&gt;
</code></pre><p>  请注意{}在Component非常常见，比如加注释。</p>
</blockquote>
<p>  对于一般的操作以后的博客再讲，本次主要是将如果调用原生控件。<br>  现在演示一下调用Toast控件。<br>  1.首先我们了解到官方有一个管理toast的js库，</p>
<pre><code>import Toast from &apos;react-native-root-toast&apos;;
</code></pre><p>写一个工具类实现Toast输出。<br>所以我们先安装一个库下载这个react-native-root-toast模块。使用npm安装</p>
<pre><code>npm install react-native-root-toast
</code></pre><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在webstorm中没有找到这个支持包的话，也没关系，直接新建一个js文件,叫ToastUtil.js.直接导入这个包，软件会提示你安装，然后就安装好了。<br><img src="http://img.blog.csdn.net/20161115130209008" alt="这里写图片描述"><br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出已经装好了。<br>  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ToastUtil写法：</p>
<pre><code>import Toast from &apos;react-native-root-toast&apos;;
export const toastShort = (content) =&gt; {
if (toast !== undefined) {
    Toast.hide(toast);
}
toast = Toast.show(content.toString(), {
    duration: Toast.durations.SHORT,
    position: Toast.positions.CENTER,
    shadow: true,
    animation: true,
    hideOnPress: true,
    delay: 0
});
};
</code></pre><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这只是举个例子，文件在根目录，所以在index.android.js中导入：</p>
<pre><code>import {toastShort} from &apos;ToastUtil&apos;
</code></pre><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击事件弹出：</p>
<pre><code>export default class yuansheng extends Component {
render() {
    return (
        &lt;View style={styles.container}&gt;
            &lt;Text style={styles.welcome}&gt;
                Welcome to React Native!
            &lt;/Text&gt;
            &lt;Text style={styles.instructions}&gt;
                To get started, edit index.android.js
            &lt;/Text&gt;
            &lt;Text style={styles.instructions}&gt;
                Shake or press menu button for dev menu test
            &lt;/Text&gt;
            &lt;TouchableOpacity onPress={()=&gt; {
                this.showtoast()
            }}&gt;
                &lt;Text&gt;Toast&lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
    );
}
showtoast() {
    toastShort(&quot;点击&quot;);
}
}
</code></pre><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者直接使用官方封装好的js文件，ToastAndroid。<br>ToastAndroid在react-native/Libraries/Components/中，通过下图可以看出：<br><img src="http://img.blog.csdn.net/20161115132706853" alt="这里写图片描述"><br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方封装了很多了原生控件，以供使用，这也是新版更新过来的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用ToastAndroid，</p>
<pre><code>import * as ToastAndroid from &quot;react-native/Libraries/Components/ToastAndroid/ToastAndroid.android&quot;;
 showtoast() {
    ToastAndroid.show(&apos;点击&apos;, ToastAndroid.SHORT);
}
</code></pre><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别忘了在import导入TouchableOpacity模块。<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，就可以使用Toast功能了。</p>
<ol>
<li>在新Android项目中打包React Native</li>
</ol>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较关心的是在已有的项目打包使用ReactNative，通过上文可知ReactNative使用的是Bundle，将文件传到目录，解压显示（可能流程描述的不准确）。<br> 所以我们可以通过对比和原有项目的联系。添加文件实现ReactNative功能。<br> 1，配置node_modlues,我建议直接把存在的这个文件夹拷贝过去，因为下载速度，，稍微有点慢。放在和Android 项目同级，同时将package.json和index.android.js拷贝过去，这个版本文件和入口。修改package.json里面的内容，比如项目名称。<br> 2，现在修改Android项目的文件，在项目的build.gradle添加ReactNative的仓库，</p>
<pre><code>url &quot;$rootDir/../node_modules/react-native/android&quot;
</code></pre><p>setting.gradle中添加</p>
<pre><code>rootProject.name = &apos;yuansheng&apos;//所在文件夹的名称
</code></pre><p>相关NDK的支持添加上<br>app的build.gradle中添加</p>
<pre><code> splits {
    abi {
        reset()
        enable enableSeparateBuildPerCPUArchitecture
        universalApk false  // If true, also generate a universal APK
        include &quot;armeabi-v7a&quot;, &quot;x86&quot;
    }
    }
 // applicationVariants are e.g. debug, release
applicationVariants.all { variant -&gt;
    variant.outputs.each { output -&gt;
        // For each separate APK per architecture, set a unique version code as described here:
        // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits
        def versionCodes = [&quot;armeabi-v7a&quot;:1, &quot;x86&quot;:2]
        def abi = output.getFilter(OutputFile.ABI)
        if (abi != null) {  // null for the universal-debug, universal-release variants
            output.versionCodeOverride =
                    versionCodes.get(abi) * 1048576 + defaultConfig.versionCode
        }
    }
}
compile &quot;com.facebook.react:react-native:+&quot;  // From node_modules

task copyDownloadableDepsToLibs(type: Copy) {
from configurations.compile
into &apos;libs&apos;
}
</code></pre><p>设置代码：<br>在androidmanifast中添加：</p>
<pre><code> &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;
  &lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;
</code></pre><p>Application要实现ReactApplication接口，</p>
<pre><code>private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
    protected boolean getUseDeveloperSupport() {
  return BuildConfig.DEBUG;
    }

@Override
protected List&lt;ReactPackage&gt; getPackages() {
  return Arrays.&lt;ReactPackage&gt;asList(
      new MainReactPackage()
  );
}
  };

  @Override
  public ReactNativeHost getReactNativeHost() {
      return mReactNativeHost;
  }
</code></pre><p>需要使用的入口是继承ReactActivity。<br>具体如何集成，我也没有找到能够100%一次性通过编译的，可能现阶段不完善吧。ReactNative的介绍先到一阶段。<br>原本想出一个微信小程序的，后来又不火了，就放弃了</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2016.10-11.14是我学习（业余时间）RN和微信小程序一个月了，学了一些控件和事件。现在在这里做一下整理和总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、React-Native的实现和相关问题的解决&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Android新布局-ConstraintLayout详解</title>
    <link href="http://yoursite.com/2016/07/27/constranintlayout/"/>
    <id>http://yoursite.com/2016/07/27/constranintlayout/</id>
    <published>2016-07-27T11:18:02.000Z</published>
    <updated>2017-07-22T08:58:41.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://blog.csdn.net/u012930328/article/details/52048531" target="_blank" rel="external">原文地址</a><br><br>谷歌在2016年的IO大会上推出的一种新的布局方式—-ConstraintLayout，这局是一种约束型的布局方式。在设置和介绍上类似IOS的自动布局。</p>
</blockquote>
<p>先放上Google的官方解析地址：<a href="https://codelabs.developers.google.com/codelabs/constraint-layout/index.html%20%E5%8E%9F%E6%96%87" target="_blank" rel="external">点击链接</a> ，虽然这个地址我从来没进去过，现在另外附上一份这个官方Demo的Github地址，git： <a href="https://github.com/googlecodelabs/constraint-layout.git" target="_blank" rel="external">https://github.com/googlecodelabs/constraint-layout.git</a><br>如果在Android studio中不会使用github，还是去找找相关资料了，毕竟这部分技能应该算的上是程序员必备了。<br>那么，从下面开始详细介绍ConstraintLayout这个布局的使用。</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><h2 id="第一步，工欲善其事"><a href="#第一步，工欲善其事" class="headerlink" title="第一步，工欲善其事"></a>第一步，工欲善其事</h2><p>首先先装上Android studio的新版，不要求是最新版，但一定是要超过2.2的版本，截止本文结束前，当前版本是2.2preview6。如果打算升级，但现在是2.1.2等稳定版，则选择更新，<br><img src="http://img.blog.csdn.net/20160727160636698" alt="这里写图片描述"><br>选择Update dialog of your IDE settings.<br><img src="http://img.blog.csdn.net/20160727160912420" alt="这里写图片描述"><br>在这里选择DEV版本。<br>虽然肯定不会升级成功，下面直接附上下载地址（PS：官方网址，需要翻墙），<a href="https://dl.google.com/dl/android/studio/ide-zips/2.2.0.0/android-studio-ide-145.2878421-windows.zip" target="_blank" rel="external">官方下载地址</a>，如果由于种种原因无法翻墙的基友们请看此处，<a href="http://pan.baidu.com/s/1jIGuAkY%20%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD" target="_blank" rel="external">百度云下载</a>。</p>
<h2 id="第二步，必先利其器"><a href="#第二步，必先利其器" class="headerlink" title="第二步，必先利其器"></a>第二步，必先利其器</h2><p> 理所当前，使用新的布局方式首先应该导包，ConstraintLayout所在的文件是android.support.constraint.ConstraintLayout，而这个文件在（箭头所指）<br> <img src="http://img.blog.csdn.net/20160727163601160" alt="这里写图片描述"><br> 使用Library Dependency可以直接导入。不明白Maven，Gradle等配置的童鞋，建议去找一些资料看，毕竟这在以后的开发中还是挺重要的。<br> 到了这一步终于可以使用ConstraintLayout这种布局方式了。<br> 在实际操作前先说一下他的性质。<br> 先看ConstraintLayout作为一个ViewGroup的子类，而他并没有没有重载onDraw的方法，他的onLayout（）方法也非常简单，<br> <img src="http://img.blog.csdn.net/20160727165148207" alt="这里写图片描述"><br> 可以看出所以源码中，他内部的子view都是以相对关系存在的，所以只要计算出子view的坐标，就能推算出其他childview该放在布局哪个位置。所以在他的layout的过程也十分简单。<br> 对于他的OnMeasure（）方法，有兴趣的同学可以去看看。另外附上一张RelativeLayout的布局，同样继承于ViewGroup，在他的onLayout（）方法中，见下图：<br> <img src="http://img.blog.csdn.net/20160727170423197" alt="这里写图片描述"><br>可以差不多的看出ConstraintLayout与RelativeLayout对于子控件的排列方式差不多，可以将ConstraintLayout理解为RelativeLayout的升级版（我也不知道这个名称是否得当，欢迎斧正）。<br>可以将ConstraintLayout当做RelativaLayout的布局使用，以及对于子控件的摆放，各位童鞋都有一些印象了吧。<br>、</p>
<h2 id="2-约束性关系"><a href="#2-约束性关系" class="headerlink" title="2.约束性关系"></a>2.约束性关系</h2><p>在这个布局中，最为关键重要的就是约束性关系这个概念。<br>我的表达能力不是很好，童鞋们理解就好，不理解的话请参考关系数据库完整性约束（大概意思）。<br>约束性关系帮助你保持子控件与子控件对齐或者存在相互的关系. 你可以使用锚点来约定子控件之间存在何种对齐方式。如下图的ButtonA与ButtonB。我们从ButtonA的锚点指向ButtonB，并约束了96dp的间距，则此时移动ButtonB则会与ButtonA保持96dp的距离，而且在移动时的ButtonA也会移动。而操作ButtonA则是很随意，这就是约束性的关系，ButtonA约束了ButtonB的行为。<br><img src="http://img.blog.csdn.net/20160727173423772" alt="这里写图片描述"><br>下图是动态操作，表述上文所述的一些行为。<br><img src="http://img.blog.csdn.net/20160727181918120" alt="这里写图片描述"></p>
<p>下面介绍一下完整的整体的各个含义：<br><img src="http://img.blog.csdn.net/20160727180829069" alt="这里写图片描述"><br>其中四个角的位置可以将控件缩放的操作点，而在四个边上的圆圈是锚点，（PS：锚点是对应的，上下的锚点只能和上下行的锚点链接，不能和左右的锚点链接），中间的椭圆形式句柄（？），这个的作用是将水平方向的控件内部的字体水平对齐。<br>下图详见操作（有一些操作现在没有讲到，比如自动对齐，这个将会在下面讲）：<br><img src="http://img.blog.csdn.net/20160727182933532" alt="这里写图片描述"></p>
<h2 id="3-正文"><a href="#3-正文" class="headerlink" title="3.正文"></a>3.正文</h2><p>上面的内容只是ConstraintLayout布局的一些基础知识点，现在我们来正式的看ConstraintLayout的使用。</p>
<p>我们先把一张图片附在布局中，成像效果如下：<br><img src="http://img.blog.csdn.net/20160727183558035" alt="这里写图片描述"><br>一些初学者会以为右侧的波浪线是图片的黑白平衡，通道，色差之类的，但很抱歉，什么也不是，是Android studio的布局中加载图片的一种显示方式。就像Button控件中有一个句柄一样，图片并没有这个东西。<br>现在我们把眼光移向右上角，会发现出现了一个2字，<img src="http://img.blog.csdn.net/20160727184053441" alt="这里写图片描述">，打开这个2（这个是错误的个数）会发现里面报了若干个（2个）错误（警告），下面来给大家讲解一下这些都是什么含义。<br><img src="http://img.blog.csdn.net/20160727184349382" alt="这里写图片描述"><br>其中第一个是：此子控件缺少约束，否则按左上角（0,0）的位置进行判断子控件的位置，这个错误在Relativelayout布局非常常见，可以不必理会。<br>在这里比较关键的是第二个警告，此控件缺少contentDescription这个节点，而这个节点同样也是新增的内容，是Android新版新增添的功能-无障碍阅读的一种实现。<br>对于Android新增的无障碍阅读功能在系统设置-无障碍里面（由于国产ROM的百花齐放，这个功能自己摸索去），这个功能的主要作用是给一些视力障碍的群体正常的使用Android系统，在触摸某些设置的控件时会发出提示音（使用Google提供的Talk软件）。而这个的操作就是依靠contentDescription这个新属性。添加地点在：<br><img src="http://img.blog.csdn.net/20160727185621243" alt="这里写图片描述"><br>点开之后是选择value，在@string/XXX下面，启动无障碍模式，会播报在此处选择的文字。<br>现在又出现一个新的面板-Properties，是对新功能的补充，如果大家还是怀念原来的样式，则打开方式是：右上角的<img src="http://img.blog.csdn.net/20160727185952263" alt="这里写图片描述"> 左右箭头的符号，顿时就有爱了，还是原来的配方，还是原来的味道。</p>
<p><img src="http://img.blog.csdn.net/20160727190109359" alt="这里写图片描述"></p>
<p>好了，扯了这么多闲话，现在正是创建约束性的操作，在通过上面的学习，相信大家对这个约束性的关系和创建约束肯定很感兴趣。</p>
<hr>
<p> <strong>1. 手工创建约束性的操作</strong><br> 容我先创建两个可亲可爱的按钮（Button），点击A Button右侧的圆圈，右侧的圆圈会出现类似呼吸灯的状态，点住按钮会出现一个箭头，将箭头想右引导，如果成功A Button会移动到B Button的旁边，而且A Button的呼吸灯变成红色（？原谅我没看出来）。到这步就手工创建好了两者的约束，可以自由操作了。<br> 具体操作如下：<br> <img src="http://img.blog.csdn.net/20160727191059768" alt="这里写图片描述"> </p>
<p> 这是两个控件中的手工创建约束，下面是单个控件与上层布局的约束。<br>这种方式比较好的地方在于可以与左右上下限定所谓的位置，类型LinearLayout的百分比的方式，<br>在代码中的体现是： <img src="http://img.blog.csdn.net/20160727191702396" alt="这里写图片描述"><br>比较好的融合了RelativeLayout和LinearLayout的优点。（对于百分比布局，将会在以后的文章中有详述）</p>
<p> <img src="http://img.blog.csdn.net/20160727191400658" alt="这里写图片描述"></p>
<p> 下面来说一下两个控件之间的基准约束条件。<br>将鼠标放置到Button A句柄处，当句柄开始变色（？）时用鼠标引导句柄，此时会从句柄处引申一条连接线，将此连接线连接到Button B 的句柄处，会发现Button A会移动到与Button B平齐（文字）的地方。（请注意右上角的警告数字，按照个人需求设置）。<br>在代码中的体现是在<img src="http://img.blog.csdn.net/20160728115622758" alt="这里写图片描述"><br>下图是如何设置的动态图<br> <img src="http://img.blog.csdn.net/20160728115110787" alt="这里写图片描述"></p>
<p>好了，个人的设置大约就是这样，下面开始介绍Properties面板的若干参数的含义。</p>
<p><img src="http://img.blog.csdn.net/20160728132014603" alt="这里写图片描述"><br>这个ImageView与上层布局的约束的状态。<br>想必各位看官们已经注意到了图中的16,50,39等数字，下面来给大家讲解一下各个数字的用处。16是当ImageView与上层布局出现约束关系时，四周与上层布局的间隔，也就是margin属性。用法一致，并没有发生改变。而50,39指的是50%和39%，相信大家看完下面的演示就会一目了然。<br><img src="http://img.blog.csdn.net/20160728133013165" alt="这里写图片描述"><br>移动这个百分比比率会影响控件在布局中的位置（演示的有点小卡），这些百分比率就是在布局中的比率的显示。<br>在这张图中，还有一些代表意义。<br>1.在上图中有<img src="http://img.blog.csdn.net/20160728133351934" alt="这里写图片描述">，wrap_content，这个的含义，在新式布局中，<br>对应的是<img src="http://img.blog.csdn.net/20160728133614532" alt="这里写图片描述"><br>对于wrap_content,在此就不做赘述，不知道或不明白的去面壁吧。<br>2.<img src="http://img.blog.csdn.net/20160728133907163" alt="这里写图片描述">，Fixed，对于这种样式，在布局中的代表含义是实际的距离，也就是我们给这个控件赋予的尺寸（指定的尺寸）。<br><img src="http://img.blog.csdn.net/20160728134034835" alt="这里写图片描述"><br>3.<img src="http://img.blog.csdn.net/20160728134151852" alt="这里写图片描述">，AnySize，对于这种样式，让子控件占用尽可能大的所有可用空间以去适应上层布局.<br><img src="http://img.blog.csdn.net/20160728134400353" alt="这里写图片描述"><br>看到在代码中的释义是不是很熟悉，又见0dp。</p>
<hr>
<p> <strong>2. 自动创建约束</strong><br> 下面来看布局上面面板的内容，有经验的同学可以很快发现这个面板和以往的有所不同。<br> <img src="http://img.blog.csdn.net/20160728134921152" alt="这里写图片描述"><br>多了下面这一排的图标，这次我们会仔细讲解一下这些图标的作用。<br>现在我们将按照逻辑来讲一下各个图标。<br>1.<img src="http://img.blog.csdn.net/20160728135403180" alt="这里写图片描述"><br>这个图标是左起第二个。作用是系统自动预测人类预期的行为而创建的约束—-简称自动创建约束（官方怎么称呼的我也不清楚）。<br>下面展示一下自动创建的流程。<br><img src="http://img.blog.csdn.net/20160729104939688" alt="这里写图片描述"><br>开启磁铁符号，将控件放置在布局中，可以清晰的看到约束的关系在自动的创建。<br>在新式布局中还有一种自动创建约束的按钮，左起第四个，<img src="http://img.blog.csdn.net/20160729105916226" alt="这里写图片描述">，点击这个按钮系统会提示控件与控件，控件与布局之间的可能存在的约束关系。<br>详情见下面的动图：<br><img src="http://img.blog.csdn.net/20160729123854137" alt="这里写图片描述"></p>
<p>这种自动约束的好处是免除自己去创建约束，但不好的地方在于约束太多，可能有很多约束不需要，而我们怎么删除这些约束呢？<br>下面我们来看第三个按钮，<img src="http://img.blog.csdn.net/20160729130758739" alt="这里写图片描述">，使用这个按钮就可以将所有的约束去除。如果不打算去除所有约束，而是不想将其显示出来，则使用第一个按钮，<img src="http://img.blog.csdn.net/20160729132501623" alt="这里写图片描述">，则可以将所有的约束关系显示/隐藏。（不贴图了，感兴趣的小伙伴们可以自己试试）<br>对于下面几个按钮，大家可以试试，是对控件进行操作。<br><img src="http://img.blog.csdn.net/20160729132727105" alt="这里写图片描述"></p>
<p>比如：<img src="http://img.blog.csdn.net/20160729132825965" alt="这里写图片描述"><br>是将控件的大小放置为可以容纳上层布局的最大的空间。</p>
<hr>
<hr>
<p>ConstraintLayout布局大约就是这些功能，现在看一下用这个布局做的一个简单的例子（丑，希望不要因为她丑而放弃他）。</p>
<p><img src="http://img.blog.csdn.net/20160729133934018" alt="这里写图片描述"></p>
<hr>
<p>在这里感谢！<a href="http://blog.csdn.net/jdsjlzx/article/details/51460581" target="_blank" rel="external">一叶飘舟</a> 大神博客的帮助，带我走进ConstraintLayout布局的大门。感谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u012930328/article/details/52048531&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&lt;br&gt;谷歌在2016年的I
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
