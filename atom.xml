<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙逝寒Android博客</title>
  <subtitle>源码之中,了无秘密</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-16T06:06:39.944Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>龙逝寒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SharedPreferencesUtils存储对象</title>
    <link href="http://yoursite.com/2017/07/16/SharedPreferencesUtils/"/>
    <id>http://yoursite.com/2017/07/16/SharedPreferencesUtils/</id>
    <published>2017-07-16T05:42:58.000Z</published>
    <updated>2017-07-16T06:06:39.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SharedPreferencesUtils存储对象"><a href="#SharedPreferencesUtils存储对象" class="headerlink" title="SharedPreferencesUtils存储对象"></a>SharedPreferencesUtils存储对象</h2><p>SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。<br>在我学习优化Utils工具包的一些常见的工具类。<br>在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。<br><a id="more"></a></p>
<ul>
<li><strong>读写基本数据类型</strong></li>
<li><strong>读写Javabean类型</strong></li>
<li><strong>读写List<javabean*>类型</javabean*></strong></li>
<li><strong>读写图片资源</strong></li>
</ul>
<hr>
<p>##1， 读写基本数据类型    </p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">/**</span></div><div class="line">    * 存储基本数据类型</div><div class="line">    * <span class="doctag">@param</span> context </div><div class="line">    * <span class="doctag">@param</span> key key</div><div class="line">    * <span class="doctag">@param</span> data value</div><div class="line">    */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">(Context context, String key, Object data)</span> </span>&#123;</div><div class="line">       String type = data.getClass().getSimpleName();</div><div class="line">       SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context</div><div class="line">               .MODE_PRIVATE);<span class="comment">//读写基本数据类型都是在一个特定的文件，以软件的包名为文件名</span></div><div class="line">       Editor editor = sharedPreferences.edit();</div><div class="line">       <span class="keyword">if</span> (<span class="string">"Integer"</span>.equals(type)) &#123;<span class="comment">//注意这里是integer对象，同下</span></div><div class="line">           editor.putInt(key, (Integer) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Boolean"</span>.equals(type)) &#123;</div><div class="line">           editor.putBoolean(key, (Boolean) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"String"</span>.equals(type)) &#123;</div><div class="line">           editor.putString(key, (String) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Float"</span>.equals(type)) &#123;</div><div class="line">           editor.putFloat(key, (Float) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Long"</span>.equals(type)) &#123;</div><div class="line">           editor.putLong(key, (Long) data);</div><div class="line">       &#125;</div><div class="line">       editor.commit();</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 读取基本数据类型</div><div class="line">    * <span class="doctag">@param</span> context</div><div class="line">    * <span class="doctag">@param</span> key key</div><div class="line">    * <span class="doctag">@param</span> defValue 当取不到值时返回默认值</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getData</span><span class="params">(Context context, String key, Object defValue)</span> </span>&#123;</div><div class="line">       String type = defValue.getClass().getSimpleName();</div><div class="line">       SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context</div><div class="line">               .MODE_PRIVATE);  <span class="comment">//defValue为为默认值，如果当前获取不到数据就返回它 </span></div><div class="line">       <span class="keyword">if</span> (<span class="string">"Integer"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getInt(key, (Integer) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Boolean"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getBoolean(key, (Boolean) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"String"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getString(key, (String) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Float"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getFloat(key, (Float) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Long"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getLong(key, (Long) defValue);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>将常用到的基本数据类型存入特定的文件中，获取的时候也十分方便快捷。（PS，string不是基本数据类型）</p>
<p>##读写Javabean类型<br>先期准备<br>Javabean是序列化的，需要继承Serializable接口，实现serialVersionUID。<br>1.判断处理是否是各个数据类型</p>
<pre><code> private static boolean isObject(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; !isSingle(clazz) &amp;&amp; !isArray(clazz) &amp;&amp; !isCollection(clazz) &amp;&amp; !isMap(clazz);
}

private static boolean isSingle(Class&lt;?&gt; clazz) {
    return isBoolean(clazz) || isNumber(clazz) || isString(clazz);
}

public static boolean isBoolean(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (Boolean.TYPE.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz));
}

public static boolean isNumber(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (Byte.TYPE.isAssignableFrom(clazz) || Short.TYPE.isAssignableFrom(clazz) || Integer.TYPE.isAssignableFrom(clazz) || Long.TYPE.isAssignableFrom(clazz) || Float.TYPE.isAssignableFrom(clazz) || Double.TYPE.isAssignableFrom(clazz) || Number.class.isAssignableFrom(clazz));
}

public static boolean isString(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (String.class.isAssignableFrom(clazz) || Character.TYPE.isAssignableFrom(clazz) || Character.class.isAssignableFrom(clazz));
}

public static boolean isArray(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; clazz.isArray();
}

public static boolean isCollection(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; Collection.class.isAssignableFrom(clazz);
}

public static boolean isMap(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; Map.class.isAssignableFrom(clazz);
}
private static boolean isParcelableCreator(Field field) {
    return Modifier.toString(field.getModifiers()).equals(&quot;public static final&quot;) &amp;&amp; &quot;CREATOR&quot;
            .equals(field.getName());
}
</code></pre><p>2,插入数据</p>
<pre><code> public static void setObject(Context context, Object o) {
    Field[] fields = o.getClass().getDeclaredFields();//获取所有声明的属性
    SharedPreferences sp = context.getSharedPreferences(o.getClass().getName(), 0);//将存储的文件名改为Javabean的包名+類名
    SharedPreferences.Editor editor = sp.edit();

    for (int i = 0; i &lt; fields.length; ++i) {
        if (!isParcelableCreator(fields[i])) {
            Class type = fields[i].getType();//类型 class java.lang.class
            String name = fields[i].getName();//名称 id
            Object e;
            if (isSingle(type)) {
                try {
                    if (type != Character.TYPE &amp;&amp; !type.equals(String.class)) {
                        if (!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)) {
                            if (type.equals(Double.TYPE)) {
                                editor.putLong(name, Double.doubleToLongBits(fields[i]
                                        .getDouble(o)));//将double类型的数值存入
                            } else if (type.equals(Float.TYPE)) {
                                editor.putFloat(name, fields[i].getFloat(o));//将float类型的数值存入
                            } else if (type.equals(Long.TYPE) &amp;&amp; !name.equals(&quot;serialVersionUID&quot;)) {
                                editor.putLong(name, fields[i].getLong(o));//将long类型的数值存入
                            } else if (type.equals(Boolean.TYPE)) {
                                editor.putBoolean(name, fields[i].getBoolean(o));//将boolean类型的数值存入
                            }
                        } else {
                            editor.putInt(name, fields[i].getInt(o));//将int类型的数值存入
                        }
                    } else {
                        e = fields[i].get(o);//将string类型的数值存入
                        editor.putString(name, null == e ? null : e.toString());
                    }
                } catch (Exception var14) {
                }
                }else if (isObject(type)) {
                    try {
                        e = fields[i].get(o);
                        if (null != e) {
                            setObject(context, e);
                        } else {
                            try {
                                setObject(context, fields[i].getClass().newInstance());//重新跑一遍
                            } catch (InstantiationException var11) {
                            }
                        }
                    } catch (Exception var12) {

                    }
                } else {
                try {
                    e = fields[i].get(o);
                    //转成json插入
                } catch (IllegalAccessException e1) {
                    e1.printStackTrace();
                }

            }
            }
        }
    editor.apply();
}

public static &lt;T&gt; T getObject(Context context, Class&lt;T&gt; clazz) {
    Object o = null;

    try {
        o = clazz.newInstance();
    } catch (InstantiationException e) {
        e.printStackTrace();
        return (T) o;
    } catch (IllegalAccessException e) {
        e.printStackTrace();
        return (T) o;
    }

    Field[] fields = clazz.getDeclaredFields();
    SharedPreferences sp = context.getSharedPreferences(clazz.getName(), 0);

    for(int i = 0; i &lt; fields.length; ++i) {
        if(!isParcelableCreator(fields[i])) {
            Class type = fields[i].getType();
            String name = fields[i].getName();
            String o_1;
            if(isSingle(type)) {
                try {
                    fields[i].setAccessible(true);
                    if(type != Character.TYPE &amp;&amp; !type.equals(String.class)) {
                        if(!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)){
                            if(type.equals(Double.TYPE)) {
                                fields[i].setDouble(o, Double.longBitsToDouble(sp.getLong(name, 0L)));
                            } else if(type.equals(Float.TYPE)) {
                                fields[i].setFloat(o, sp.getFloat(name, 0.0F));
                            } else if(type.equals(Long.TYPE)) {
                                fields[i].setLong(o, sp.getLong(name, 0L));
                            } else if(type.equals(Boolean.TYPE)) {
                                fields[i].setBoolean(o, sp.getBoolean(name, false));
                            }
                        } else {
                            fields[i].setInt(o, sp.getInt(name, 0));
                        }
                    } else {
                        o_1 = sp.getString(name, (String)null);
                        if(null != o_1) {
                            fields[i].set(o, o_1);
                        }
                    }
                } catch (Exception e) {

                }
            } else if(isObject(type)) {
                Object tempValue = getObject(context, fields[i].getType());
                if(null != tempValue) {
                    fields[i].setAccessible(true);

                    try {
                        fields[i].set(o, tempValue);
                    } catch (Exception e) {

                    } 
                }
            } else {
                //json数据解析
            }
        }
    }

    return (T) o;
}
</code></pre><p>主要的思想就是遍历javabean所有的属性对象，取出，按照类型一个个的存入XML文件中。<br>取出时也是同时转成了存入的形式，很方便利</p>
<h2 id="读写List-lt-Javabean-gt"><a href="#读写List-lt-Javabean-gt" class="headerlink" title="读写List&lt;Javabean&gt;"></a>读写List&lt;<em>Javabean</em>&gt;</h2><p>对于list&lt;<em>javabean</em>&gt;，不太适合用上面的方法，一般来说不太会存这种数据，数据量比较大。如果有这个需求，可以把list&lt;<em>javabean</em>&gt;转成json形式，然后存入xml文件中。关于Javabean数据转成json会在另一篇叙述。</p>
<p>##读写图片资源</p>
<p>所谓的读写图片，个人感觉用处不大，先说一下思路。其实也很简单，就是通过base64将输出流转成string。<br>代码奉上：</p>
<pre><code> private void saveBitmapToSharedPreferences(Context context,String key,Bitmap bitmap){  
    //第一步:将Bitmap压缩至字节数组输出流ByteArrayOutputStream  
    ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();  
    bitmap.compress(CompressFormat.PNG, 80, byteArrayOutputStream);  
    //第二步:利用Base64将字节数组输出流中的数据转换成字符串String  
    byte[] byteArray=byteArrayOutputStream.toByteArray();  
    String imageString=new String(Base64.encodeToString(byteArray, Base64.DEFAULT));  
    //第三步:将String保持至SharedPreferences  
    SharedPreferences sharedPreferences=context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);  
    Editor editor=sharedPreferences.edit();  
    editor.putString(key, imageString);  
    editor.commit();  
}  

private Bitmap getBitmapFromSharedPreferences(Context context, String key, Object defValue){  
    SharedPreferences sharedPreferences=getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);  
    //第一步:取出字符串形式的Bitmap  
    String imageString=context.sharedPreferences.getString(key,defValue);  
    //第二步:利用Base64将字符串转换为ByteArrayInputStream  
    byte[] byteArray=Base64.decode(imageString, Base64.DEFAULT);  
    ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(byteArray);  
    //第三步:利用ByteArrayInputStream生成Bitmap  
    Bitmap bitmap=BitmapFactory.decodeStream(byteArrayInputStream);  
    return bitmap; 
}  
</code></pre><p>##结束<br>简单叙述了下SharedPreferences的使用，毕竟作为Android中几个主要的存储数据的方式，熟练掌握还是 非常有必要的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SharedPreferencesUtils存储对象&quot;&gt;&lt;a href=&quot;#SharedPreferencesUtils存储对象&quot; class=&quot;headerlink&quot; title=&quot;SharedPreferencesUtils存储对象&quot;&gt;&lt;/a&gt;SharedPreferencesUtils存储对象&lt;/h2&gt;&lt;p&gt;SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。&lt;br&gt;在我学习优化Utils工具包的一些常见的工具类。&lt;br&gt;在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>EventBus翻译</title>
    <link href="http://yoursite.com/2017/07/16/eventBus/"/>
    <id>http://yoursite.com/2017/07/16/eventBus/</id>
    <published>2017-07-16T05:42:58.000Z</published>
    <updated>2017-07-16T10:23:21.478Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是RxBus的权威文章的翻译,<a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">原文</a>，也算是写Retrofit+RxJava学习的开端 ，在以后的博客中会陆续介绍这种框架使用的好处（可能不会连续发布）。<br>这篇文章有三个部分：</p>
<ul>
<li>1.事件总线快速入门</li>
<li>2.用RxJava实现事件总线</li>
<li>3.这种方法的离别思念</li>
</ul>
<p>“RxBus”将不会成为一个库。实现事件总线RxJava是如此容易以至于它不能作为一个独立的库。</p>
<p>##第1部分：什么是事件总线？<br>让我们来谈谈两个似乎相似的概念：观察者模式和发布 - 订阅模式。<br>观察者模式<br>这是一个发展模式，借助此，你的类或主对象（被称为可观察者）利用相关信息（事件）通知其他感兴趣的类或对象（称为观察者）。<br>发布 - 订阅模式<br>发布 - 订阅模式的目标和观察者模式的目标是完全一样的，即你想要一些其他的类来了解正在发生的某些事件。<br>尽管如此，观察者模式和发布 - 订阅模式之间存在一个重要的语义差别：发布 - 订阅模式的重点是外界“广播”的消息。观察者并不关注事件传给谁，而只关注事件是否已经传出。换句话说，观察者（发布者）并不关注谁是观察员（订阅者）。<br>为什么匿名？<br>它允许这个东西叫做“脱钩”，这是计算机编程具有良好的口碑。在设计中，你想尽可能的保持低耦合。<br>通常情况下，你会期望发布者对每个它需要通知的用户有直接的了解，所以当事件或消息已准备就绪时，它可以去通知他们每个人。但随着事件的总线的出现，发布者被解除该任务，并且这种独立性有所帮助，因为发布者和订阅者不必有建立两者之间相关性的逻辑代码。<br>换句话说“自觉低耦论”是你的代码在书写时就应该所思考的，这是程序员应该有的水平。<br>如何匿名？<br>在发布 - 订阅模式中一个很自然的问题是：你如何真正地实现发布者和订阅者之间的匿名？一个简单的方法是得到一个中间人，让那个中间人负责所有的通信。而事件总线就是这样的一个中间人。<br>事件总线就是这么简单。<br>常用于Android的使用的两个事件总线库是otto和EventBus。网上有大量的帖子解释如何在你的手机应用程序中实现它们。</p>
<p>##第2部分：用总线RxJava实现事件（？？是“在”还是“用”）<br>我已经将使用Android上RxJava的显示世界的例子粘贴在这个GitHub库上，所以我会坚持展示其完整的实现方式。下面是执行的部分代码：</p>
<pre><code>// this is the middleman object
public class RxBus {

private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create());
  public void send(Object o) {
        _bus.onNext(o);
  }

  public Observable&lt;Object&gt; toObserverable() {
    return _bus;
  }
}
</code></pre><p>你现在有一个事件总线可以使用了。<br>这是你如何将事件发布到总线：</p>
<pre><code>@OnClick(R.id.btn_demo_rxbus_tap)
public void onTapButtonClicked() {

_rxBus.send(new TapEvent());
}
</code></pre><p>这是你如何倾听来自其他片段/服务等。</p>
<pre><code>_rxBus.toObserverable()
.subscribe(new Action1&lt;Object&gt;() {
  @Override
  public void call(Object event) {

    if(event instanceof TapEvent) {
      _showTapText();

    }else if(event instanceof SomeOtherEvent) {
      _doSomethingElse();
    }
  }
});
</code></pre><p>在这个例子中，我们后从顶部片段（绿色部分）的事件，并从底部片段（蓝色部分）中（通过总线）收听。<br>在下面这个例子中，我们从顶部片段（绿色方）发布事件，并从底部片段（蓝色部分）收听（通过事件总线）。</p>
<p>##第3部分 - 离别的思念</p>
<p>死亡事件</p>
<p>在一些情况下，知道是否有观察者监听当前总线是非常有用的。比如，如果你使用事件总线来处理你的GCM推送通知），如果应用程序是在前台 ，此时你不希望发送推送通知，这时，监听“死亡事件”是非常重要的。<br>例如，在不久前发布的婚礼派对，我们增加了“信息”到我们的应用程序。如果用户的应用程序开启（因而具有至少一个或更多的听众到总线），我们不会发送推送通知，但如果他们的应用程序在后台，那么我们发送推送通知，让他们知道聊天信息。当一个事件被发布到事件总线后，如果没有用户在听，会返回一个死亡事件。如果我们得到一个死亡事件，推送通知的将被发送出去。<br>你将怎样利用RxBus来实现呢？</p>
<p>事实上，这很容易。受试者有一个有用的方法hasObservers，这将准确的告诉我们实现方式。这被添加RxJava的1.x release 中，所以你必须要安装RxAndroid的最新版本才能看到这种方法（0.23.0）。<br>如果你只是想在Andr​​oid应用程序中使用事件总线，你可能最好使用otto（强烈推荐）或EventBus库 。Otto有一个由注解推动的干净的API，可能更为简单易用。</p>
<p>虽然这篇文章写得很好，翻译的不好，以下的博客将会介绍EventBus的一般使用和RXJava及RxBus的使用。<br><a href="http://blog.csdn.net/u012930328/article/details/51993346" target="_blank" rel="external">Csdn原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是RxBus的权威文章的翻译,&lt;a href=&quot;http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/&quot; target=&quot;_blank
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
