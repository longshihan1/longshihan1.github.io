<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙逝寒Android博客</title>
  <subtitle>源码之中,了无秘密</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-19T13:28:22.290Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>龙逝寒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 系列（一） 动态代理（下）</title>
    <link href="http://yoursite.com/2017/07/18/dongtaidaili3/"/>
    <id>http://yoursite.com/2017/07/18/dongtaidaili3/</id>
    <published>2017-07-18T08:22:02.000Z</published>
    <updated>2017-07-19T13:28:22.290Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前两章想必大家都知道动态代理是怎么回事，本小节的内容是动态代理的实践操作了。在Android项目中如何实现按钮的防双击（防抖动）。<br>这个在Android上又叫Hook技术</p>
</blockquote>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>对于一些特定需求使用也是非常无可奈何的，比如Android里面对所有的点击事件进行一定的操作，比如防双击（防抖动），插桩等。<br>对于这种需求的解决方案肯定不止一个了，现在通用的（大众的）解决方案有六个：</p>
<p>1、每个调用的时候处理，点击第一下之后将按钮不可点击状态，轮询一定时间之后变为可点击状态（代码不贴了，估计没人会这么写）<br>2、写一个工具类，返回布尔型，在里面计算点击周期等，（同样不建议）<br>3、复写view.onClickeListener,重新定义一个抽象类，承接OnClickListener的事件，在进行处理完之后分发，</p>
<pre><code>public abstract class NoDoubleClickListener implements View.OnClickListener {
private int MIN_CLICK_DELAY_TIME = 500;

private long lastClickTime = 0;

public abstract void onNoDoubleClick(View v);

@Override
public void onClick(View v) {
    long currentTime = Calendar.getInstance().getTimeInMillis();
    if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) {
        lastClickTime = currentTime;
        onNoDoubleClick(v);
    }
    }
}
</code></pre><p>4、RxBinding操作，或者RXJava自己封装<br>  通过学习RXJava可知有一个操作符throttleFirst ,作用是在一定时间内的时间，只发送第一条事件，和debounce,作用是在一定时间没有变化才会发送事件。<br>  所以可以使用RxBinding：</p>
<pre><code>RxView.clickEvents(button)
.throttleFirst(500, TimeUnit.MILLISECONDS)
.subscribe(clickAction);
</code></pre><p>看起来是不是很简单，但是要导入Rxjava相关的框架，还会破坏butterknife的结构，小伙伴可以想想怎么写。</p>
<p>5、使用装饰器模式<br>   理论上可以实现，但没有写过，小伙伴可以试试。<br>6、动态代理<br>   本节内容的重头戏，在下部分详细概述怎么写的。</p>
<h2 id="2-动态代理实现仿双击"><a href="#2-动态代理实现仿双击" class="headerlink" title="2.动态代理实现仿双击"></a>2.动态代理实现仿双击</h2><ul>
<li>#确定需求<br>我们的具体需求是什么，android上的动态代理的形式和Java有什么不同，虽然Android程序是用java编写的（原生）。<ol>
<li>首次Android中的Activity是有生命周期的，所以要在所有使用的地方注册</li>
<li>找到所要插入的点<br> 每次使用SetOnClickListener的方法，在View的方法里面<br> <img src="http://oqsn5psbq.bkt.clouddn.com/listenerInfo.png?attname=&amp;e=1500457180&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:wBKxW0c65_h8AV2_ynVDAmoHQ0U" alt=""><br><img src="http://oqsn5psbq.bkt.clouddn.com/listener2.png?attname=&amp;e=1500458419&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:J6QURGwKDiRbLJF0RP_Z_77voRc" alt=""><br>都会使用ListenerInfo这个类，下面看看这个类<br><img src="http://oqsn5psbq.bkt.clouddn.com/listenerinfo1.png?attname=&amp;e=1500457255&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:anYDKr50ZXwFPq27ZUzjid-0eH8" alt="">   </li>
</ol>
</li>
</ul>
<p>所以我们按图索骥，一步一步的找到真正实现的接口的地方，就是在ListenerInfo的OnClickListener。对于这个类我们也可以看出，所有的触摸事件（包括滑动，长按，按键等）都是在这个位置进行监听的。<br>下面我们来写动态代理的代码：</p>
<pre><code>Class viewClass = Class.forName(&quot;android.view.View&quot;);
      Method method = viewClass.getDeclaredMethod(&quot;getListenerInfo&quot;);
      method.setAccessible(true);
      Object listenerInfoInstance = method.invoke(view);

      //hook信息载体实例listenerInfo的属性
      Class listenerInfoClass = Class.forName(&quot;android.view.View$ListenerInfo&quot;);

      Field onClickListerField = listenerInfoClass.getDeclaredField(&quot;mOnClickListener&quot;);
      onClickListerField.setAccessible(true);
      View.OnClickListener onClickListerObj = (View.OnClickListener) onClickListerField.get(listenerInfoInstance);//获取已设置过的监听器

      if (isScrollAbsListview &amp;&amp; onClickListerObj instanceof OnClickListenerProxy) {//针对adapterView的滚动item复用会导致重复hook代理监听器
          return;
      }
      //hook事件，设置自定义的载体事件监听器
      onClickListerField.set(listenerInfoInstance, new OnClickListenerProxy(onClickListerObj, proxyListenerConfigBuilder.getOnClickProxyListener()));
      setHookedTag(view, R.id.tag_onclick);
</code></pre><p>其中OnClickListenerProxy就是我们要实现的对象，在这里要注意给view设置一个Tag,否则会出现重复代理的情况。<br>下面我们来看看这个代理对象的实现（其实很简单的）：</p>
<pre><code>public class OnClickListenerProxy implements View.OnClickListener {

private static final String TAG = &quot;OnClickListenerProxy&quot;;
private View.OnClickListener onClickListener;
private int MIN_CLICK_DELAY_TIME = 1000;
private long lastClickTime = 0;


private OnListenerProxyCallBack.OnClickProxyListener onClickProxyListener;

public OnClickListenerProxy(View.OnClickListener onClickListener, OnListenerProxyCallBack
        .OnClickProxyListener onClickProxyListener) {
    this.onClickListener = onClickListener;
    this.onClickProxyListener = onClickProxyListener;
}

@Override
public void onClick(final View v) {
    long currentTime = Calendar.getInstance().getTimeInMillis();
    //System.out.println(&quot;--------------&quot; + (currentTime - lastClickTime) + &quot;--------------&quot;);
    if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) {
        lastClickTime = currentTime;
      //  Log.e(&quot;OnClickListenerProxy&quot;, &quot;OnClickListenerProxy&quot;+v.getTag());
        Context context = v.getContext();
        if (context instanceof Activity) {
           // Log.e(&quot;OnClickListenerProxy&quot;, context.getClass().getSimpleName());
        }
        if (null != onClickProxyListener) {//点击代理回调
            onClickProxyListener.onClickProxy(v);
        }
        if (null != onClickListener) {
            onClickListener.onClick(v);
        }
    }
}
}
</code></pre><p>通过Context可以判断Activity的，和获取Activity的具体名称，对于插桩是方便的。<br>同理我们可以实现对于长按事件的监听，甚至于对Listview的Item的点击事件，Recyclerview的Item的点击事件。<br>下面我们来看看Hook的代理的入口：</p>
<pre><code> public void hookStart(Activity activity) {
    if (null != activity) {
        View view = activity.getWindow().getDecorView();
        if (null != view) {
            if (view instanceof ViewGroup) {
                hookStart((ViewGroup) view);
            } else {
                hookOnClickListener(view, false);
                hookOnLongClickListener(view, false);
            }
        }
    }
}
</code></pre><p>这只是一种很简单的情况，但如果像列表控件带滚动的形式，又是另一种处理方式，这是因为Android内部的缓存机制导致的这样的问题。</p>
<pre><code>public void hookStart(ViewGroup viewGroup, boolean isScrollAbsListview) {
    if (viewGroup == null) {
        return;
    }
    int count = viewGroup.getChildCount();
    for (int i = 0; i &lt; count; i++) {
        View view = viewGroup.getChildAt(i);
        if (view instanceof ViewGroup) {//递归查询所有子view
            // 若是布局控件（LinearLayout或RelativeLayout）,继续查询子View
            hookStart((ViewGroup) view, isScrollAbsListview);
        } else {
            hookOnClickListener(view, isScrollAbsListview);
            hookOnLongClickListener(view, isScrollAbsListview);
        }
    }
    hookOnClickListener(viewGroup, isScrollAbsListview);
    hookOnLongClickListener(viewGroup, isScrollAbsListview);
    hookListViewListener(viewGroup);
}
</code></pre><p>必须到递归获取到所有的view控件才可以继续向下运行。</p>
<p>对于在基类里面调用代理呢，肯定是要在view绘制完全的时候，</p>
<pre><code> private boolean isHookListener = false;

@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (isHookListener) {//防止退出的时候还hook
        return;
    }

    getWindow().getDecorView().post(new Runnable() {
        @Override
        public void run() {//等待view都执行完毕之后再hook,否则onLayoutChange执行多次就会hook多次
            HookViewManager.getInstance().hookStart((Activity) mContext);
            isHookListener = true;
        }
    });

}
</code></pre><p>直到这一步才正式的代理了view的相关事件的监听。</p>
<h2 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3.结束语"></a>3.结束语</h2><p>会思考的童鞋会由此思考Hook技术是怎么回事？</p>
<blockquote>
<p>1.Hook英文翻译为“钩子”，而钩子就是在事件传送到终点前截获并监控事件的传输，像个钩子钩上事件一样，并且能够在钩上事件时，处理一些自己特定的事件；<br>2.Hook使它能够将自己的代码“融入”被勾住（Hook）的进程中，成为目标进程的一部分；<br>3.在Andorid沙箱机制下，Hook是我们能通过一个程序改变其他程序某些行为得以实现； </p>
</blockquote>
<p>第一条是不是很熟悉，其实在java层面大部分的Hook都是通过代理实现的，但Hook技术不止包括java层面，还有Native层面，也就是C/C++层面，Android中著名的Hook框架就是——Xposed平台。<br>Hook技术的成功很广泛，只要你像在Android手机上做点黑科技，Hook技术是你必不可少的知识点，包括现在著名的插件化浪潮，也是在其基础上引申拓展的。<br><br>动态代理三部分讲完了，下节将开始我们新的学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前两章想必大家都知道动态代理是怎么回事，本小节的内容是动态代理的实践操作了。在Android项目中如何实现按钮的防双击（防抖动）。&lt;br&gt;这个在Android上又叫Hook技术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a 
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 系列（一） 动态代理（上）</title>
    <link href="http://yoursite.com/2017/07/18/dongtaidaili1/"/>
    <id>http://yoursite.com/2017/07/18/dongtaidaili1/</id>
    <published>2017-07-18T05:17:02.000Z</published>
    <updated>2017-07-18T12:51:08.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>想必大家都很耳熟这个模式，或者说这个思想，但实际在项目中用的并不是很多，这节课程我们来详细描述-动态代理是怎么一回事，和使用的范围，以及一定程度的扩展，在Android中的简单实现。</p>
</blockquote>
<h2 id="动态代理的介绍"><a href="#动态代理的介绍" class="headerlink" title="动态代理的介绍"></a>动态代理的介绍</h2><h1 id="1-什么是动态代理"><a href="#1-什么是动态代理" class="headerlink" title="1.什么是动态代理"></a>1.什么是动态代理</h1><ul>
<li>定义：为其他对象提供一种代理以控制对这个对象的访问<br>请注意这个控制，仅代表在这个对象处理之前或之后做某些操作，并不会对这个对象做什么操作，也不会影响这个事务的运行。<br>其中动态代理只是代理模式的一种，代理模式还包括静态代理等。</li>
<li>优缺点：可以实现对于委托类的隐藏，可以对于统一的操作节约代码，实现解耦，但jdk中的proxy只能实现对接口的代理，如果想代理其他的方法等，需要用到第三方的sdk.</li>
<li>使用典范：spring的AOP模式，日志系统，缓存系统等。</li>
<li><p>例图：<br> 1，代理模式<br> <img src="http://oqsn5psbq.bkt.clouddn.com/%E4%BB%A3%E7%90%86.png?attname=&amp;e=1500350970&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:PE21Q_Kc_DgYMOOERQV91i7FrJI" alt="代理模式"></p>
<p> 2，动态代理模式<br> <img src="http://oqsn5psbq.bkt.clouddn.com/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png?attname=&amp;e=1500350970&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:-PHNRvWxQMQpOTKebKWu1HUBTho" alt=""></p>
</li>
<li><p>我的看法<br>动态代理模式存在的必要：我们在写主业务流程时，经常会遇到一些细枝末节的东西要处理，比如缓存，写日志等，但如果将其直接放在主题代码中，这是对OO的破坏，也会影响整体业务流程的浏览，另一方面会做很多无用功，有人会说：把这种代码抽出来，放在一个基类里面。当然这不失为一种解决方案，但会造成主体代码和枝节代码的耦合加深，会使在模块中依旧添加其他的依赖，而且对于代码移植比较繁琐。<br>所以我们使用动态代理这种思想，降低了代码的耦合程度，也更好的隐藏枝节代码，和保护主体代码。<br>看到这里有人会很疑惑，动态代理怎么和装饰器模式这么类似，我们将会在下节将装饰器模式和动态代理的不同，以及两者的之间的互补。</p>
</li>
</ul>
<h1 id="2-动态代理的实现"><a href="#2-动态代理的实现" class="headerlink" title="2.动态代理的实现"></a>2.动态代理的实现</h1><p>  下面来看一下代码演示（没有使用《Java编程思想》和《设计模式之禅》的代码，详情请参考这两本书）</p>
<p>  1，接口</p>
<pre><code>public interface Subject {
    public void rent();
    public void hello(String str);
}
</code></pre><p>  2，实现类，这个类就是我们的真实对象</p>
<pre><code>public class RealSubject implements Subject {
    @Override
    public void rent() {
        System.out.println(&quot;I want to rent my house&quot;);
    }

    @Override
    public void hello(String str) {
        System.out.println(&quot;hello: &quot; + str);
    }
}
</code></pre><p>  3，要代理的方法</p>
<pre><code>public class DynamicProxy implements InvocationHandler {
//　这个就是我们要代理的真实对象
private Object subject;

//    构造方法，给我们要代理的真实对象赋初值
public DynamicProxy(Object subject) {
    this.subject = subject;
}

@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //　　在代理真实对象前我们可以添加一些自己的操作
    System.out.println(&quot;before rent house&quot;);
    //   真实的方法
    System.out.println(&quot;Method:&quot; + method);

    //    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
    method.invoke(subject, args);

    //　　在代理真实对象后我们也可以添加一些自己的操作
    System.out.println(&quot;after rent house&quot;);

    return null;
}
}
</code></pre><p>4，Client方法</p>
<pre><code>public class Client {

public static void main(String[] args) {
    //    我们要代理的真实对象
    Subject realSubject = new RealSubject();

    //    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的
    InvocationHandler handler = new DynamicProxy(realSubject);

    /*
     * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
     * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象
     * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了
     * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
     */
    Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject
            .getClass().getInterfaces(), handler);

    System.out.println(subject.getClass().getName());
    subject.rent();
    subject.hello(&quot;world&quot;);
}
}
</code></pre><p>  5,总结</p>
<p>动态代理的步骤总结:</p><p><br>1,定义一个接口，并实现这个接口的类，就是实现类，或者称为委托类</p><p><br>2，定义一个代理类，实现jdk的InvocationHandler接口（这个接口在java.lang.reflect包里面，想必大家可以猜到内部怎么实现的吧），主要是将运行时的任务和你准备处理的操作进行搭配。</p><p><br>3,生成代理对象，调用Proxy的方法进行调用，使用。</p>
<p>#3. 结束语</p>
<p>简单的动态代理的代码就是这么多，下节将装饰器模式和动态代理的搭配，通过简单的代码模拟，大家是不是对动态代理已经有所认识，赶快行动起来吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;想必大家都很耳熟这个模式，或者说这个思想，但实际在项目中用的并不是很多，这节课程我们来详细描述-动态代理是怎么一回事，和使用的范围，以及一定程度的扩展，在Android中的简单实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;动态代理的介
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 系列（一） 动态代理（中）</title>
    <link href="http://yoursite.com/2017/07/18/dongtaidaili2/"/>
    <id>http://yoursite.com/2017/07/18/dongtaidaili2/</id>
    <published>2017-07-18T05:17:02.000Z</published>
    <updated>2017-07-18T12:51:08.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>从上节的学习想必大家都知道动态代理怎么写了，现在我们拓展一些，动态代理和装饰器模式，想必大家都很困惑。本小节主要介绍动态代理和装饰器模式的不同以及如何相互搭配。</p>
</blockquote>
<h1 id="1-动态代理和装饰器模式"><a href="#1-动态代理和装饰器模式" class="headerlink" title="1.动态代理和装饰器模式"></a>1.动态代理和装饰器模式</h1><ul>
<li><p>1.装饰器模式的介绍：</p>
<p> 装饰器模式能够实现保持原有的接口，并为新的接口动态的添加功能。装饰器实现了java编程上的一个准则，多组合，少继承。<br><br> 装饰器的一个典型的例子是：java中的IO流的实现,大家在转过头来看javaIO流的思维导图，想必会恍然大悟了。<br><br> 例图：<br></p>
<p> <img src="http://oqsn5psbq.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E5%99%A8.png?attname=&amp;e=1500359908&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:JEwQihnnKKrIwO7F-opjm8QSelQ" alt=""></p>
<p> （ps:这个图会和我们下面将要讲的装饰器模式+动态代理的UML图一致，不再重复显示）</p>
</li>
<li><p>2.两者区别</p>
</li>
</ul>
<p>两者都可以在保持主业务流程下，对对象进行添加方法，增强这个类的使用。<br><br>   但两者有着一些区别：<br><br>   装饰器模式继承了接口，添加了新类，而代理没有对原代码有任何操作。<br><br>   装饰器中的继承和创建新类，会造成出现大量的包装类，对于代码阅读是有困难的。</p>
<h1 id="2-动态代理的装饰器模式搭配"><a href="#2-动态代理的装饰器模式搭配" class="headerlink" title="2.动态代理的装饰器模式搭配"></a>2.动态代理的装饰器模式搭配</h1><p>为什么要这样搭配呢，想必大家在实践过程中使用代理都会遇到的问题–动态代理的扩展性。<br>动态代理是没有办法在源代理类上直接进行拓展的（否则的话全部的接口都会实现拓展的对象），但对于我们来说，并不需要，只是对某些委托类进行操作，这就不太这么方便操作了。所以这时候使用装饰器模式比较好的搭配使用，添加自定义的扩展。<br><br>相对于简单的动态代理，这时候要增加几个新的方法：<br><br>提供动态代理实例的静态工厂类（ProxyFactory）和抽象装饰器（Decorator）<br></p>
<ul>
<li>首次我们看抽象主题接口</li>
</ul>
<pre><code>public interface AbstractSubject {
     void request();
}
</code></pre><ul>
<li>真实主题类（委托类/被代理的对象）</li>
</ul>
<pre><code>public class RealSubject implements AbstractSubject {
public void request() {
    System.out.println(&quot;真实的方法-----RealSubject&apos;s request() ...&quot;);
}
}
</code></pre><ul>
<li>抽象装饰器类（一定要以自己的父类、父接口为一个属性） </li>
</ul>
<pre><code>public class Decorator implements AbstractSubject {
protected AbstractSubject subject = null;

public Decorator(AbstractSubject subject) {
    this.subject = subject;
}

@Override
public void request() {

}
}
</code></pre><ul>
<li>具体装饰器1（根据实际情况，我这里只写三个）</li>
</ul>
<pre><code>public class ConcreteDecorator01 extends Decorator {

public ConcreteDecorator01(AbstractSubject subject) {
    super(subject); //调用父类装饰类的构造器
}

/**
 * 覆盖继承树上的接口中的request()方法，用于装饰原对象
 */
public void request() {
    System.out.println(&quot;第一层装饰 ... 装饰在原主题之前&quot;);
    super.subject.request();
}
}
</code></pre><ul>
<li>具体装饰器2（根据实际情况，我这里只写三个）</li>
</ul>
<pre><code>public class ConcreteDecorator02 extends Decorator {

public ConcreteDecorator02(AbstractSubject subject) {
    super(subject); //调用父类装饰类的构造器
}

/**
 * 覆盖继承树上的接口中的request()方法，用于装饰原对象
 */
public void request() {
    super.subject.request();
    System.out.println(&quot;第二层装饰 ... 装饰在原主题之后&quot;);
}
}
</code></pre><ul>
<li>具体装饰器3（根据实际情况，我这里只写三个）</li>
</ul>
<pre><code>public class ConcreteDecorator03 extends Decorator {

public ConcreteDecorator03(AbstractSubject subject) {
    super(subject); //调用父类装饰类的构造器
}

/**
 * 覆盖继承树上的接口中的request()方法，用于装饰原对象
 */
public void request() {
    super.subject.request();
    System.out.println(&quot;第三层装饰 ... 装饰在原主题之后&quot;);
}
}
</code></pre><ul>
<li>提供动态代理实例的静态工厂类（管理代理实现）</li>
</ul>
<pre><code>public class ProxyFactory {
/**
 * @param realSubject ：指定需要代理的真实主题类的实例
 * @return proxy ：代理的实例
 */
public static AbstractSubject getProxy(AbstractSubject realSubject) {

    // 获得被代理类的类加载器，使得JVM能够加载并找到被代理类的内部结构，以及已实现的interface
    ClassLoader loader = realSubject.getClass().getClassLoader();

    // 获得被代理类已实现的所有接口interface,使得动态代理类的实例
    Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces();

    // 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序
    InvocationHandler handler = new DynamicProxy(realSubject);

    /*
     * 使用java.lang.reflect.Proxy类中的静态方法newProxyInstance()获得代理的实例
     *
     * loader : 被代理类的类加载器 interfaces ：被代理类已实现的所有接口，而这些是动态代理类要实现的接口列表 handler
     * ： 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序
     *
     * return ：返回实现了被代理类所实现的所有接口的Object对象，即动态代理，需要强制转型
     */
    AbstractSubject proxy = (AbstractSubject) Proxy.newProxyInstance(
            loader, interfaces, handler);

    return proxy;
}
}
</code></pre><ul>
<li>代理类</li>
</ul>
<pre><code>public class DynamicProxy implements InvocationHandler {

// 被代理类的实例
Object obj = null;

// 将被代理者的实例传进动态代理类的构造函数中
public DynamicProxy(Object obj) {
    this.obj = obj;
}

/**
 * 覆盖InvocationHandler接口中的invoke()方法
 *
 * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到
 * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊 代码切入的扩展点了。
 */
public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
    /*
     * before ：doSomething();
     */
    System.out.println(&quot;动态代理为真实主题添加一个方法  ...&quot;);
    Object result = method.invoke(this.obj, args);

    /*
     * after : doSomething();
     */
    return result;
}
}
</code></pre><ul>
<li>client</li>
</ul>
<pre><code>public class Client {
public static void main(String[] args) {
    // 被代理类的实例
    AbstractSubject realSubject = new RealSubject();
    // 通过静态工厂获取动态代理的实例
    AbstractSubject proxy = ProxyFactory.getProxy(realSubject);
    // 装饰之前打印出该代理实例的名称
    System.out.println(&quot;装饰前：&quot; + proxy.getClass().getName());
    // 装饰前使用代理实例进行原始操作
    //proxy.request();
    System.out.println(&quot;\n第一次装饰之后的效果如下：&quot;);
    proxy = new ConcreteDecorator01(proxy);
    System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName());
    //proxy.request();

    System.out.println(&quot;\n第二次装饰之后的效果如下：&quot;);
    proxy = new ConcreteDecorator02(proxy);
    System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName());
   // proxy.request();

    System.out.println(&quot;\n第三次装饰之后的效果如下：&quot;);
    proxy = new ConcreteDecorator03(proxy);
    System.out.println(&quot;\n名称：&quot; + proxy.getClass().getName());
    proxy.request();
}
}
</code></pre><ul>
<li><p>总结 </p>
<p> 通过上面的代码描述可以在proxy这个类已经是处理好之后的情况，在后面的大段代码都是标准的装饰器代码。<br><br> 运行之后：<br><img src="http://oqsn5psbq.bkt.clouddn.com/%E4%BB%A3%E7%90%86%E8%A3%85%E9%A5%B0.png?attname=&amp;e=1500367034&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:g_IrjFnUOSlGzblI2M1_mVjL4zw" alt=""><br>看好我画圈的地方，下面将 </p>
<blockquote>
<p>AbstractSubject proxy = ProxyFactory.getProxy(realSubject);</p>
</blockquote>
</li>
</ul>
<p>方法去除，变成一个完整的装饰器模式，看看效果：<br><img src="http://oqsn5psbq.bkt.clouddn.com/=%E8%A3%85%E9%A5%B0%E5%99%A8.png?attname=&amp;e=1500367040&amp;token=4c_iy_FSofVZ5RZGp4Zc590p4SyhlYTmvUW9e6Rr:W9i0FDPrPHKw0eqlUl5Nr1VncqY" alt=""></p>
<p>可以看到，结果完全相同，只有最初代理的对象不同，一个是经过代理产生的，一个是源接口。<br>对于这样的好处毋庸置疑：代理可以放在其他模块中，对于自定义的功能添加使用装饰器自由组合，对于统一的操作放在代理对象中，这样解耦的形式比较好。</p>
<h1 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3.结束语"></a>3.结束语</h1><p>其实设计模式之前的搭配有很多，只学单独的设计模式的概念并不是很大，很多注明的SDK都是很多设计模式相互搭配而来，请大家多多思考，下节讲动态代理的实际操作–Android中统一处理防双击/抖动。谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从上节的学习想必大家都知道动态代理怎么写了，现在我们拓展一些，动态代理和装饰器模式，想必大家都很困惑。本小节主要介绍动态代理和装饰器模式的不同以及如何相互搭配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-动态代理和装饰器模式&quot;&gt;&lt;a 
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferencesUtils存储对象</title>
    <link href="http://yoursite.com/2017/07/16/SharedPreferencesUtils/"/>
    <id>http://yoursite.com/2017/07/16/SharedPreferencesUtils/</id>
    <published>2017-07-16T05:42:58.000Z</published>
    <updated>2017-07-16T10:32:21.148Z</updated>
    
    <content type="html"><![CDATA[<p>SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。<br>在我学习优化Utils工具包的一些常见的工具类。<br>在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。<br><a id="more"></a></p>
<ul>
<li><strong>读写基本数据类型</strong></li>
<li><strong>读写Javabean类型</strong></li>
<li><strong>读写List<javabean*>类型</javabean*></strong></li>
<li><strong>读写图片资源</strong></li>
</ul>
<hr>
<h2 id="1-读写基本数据类型"><a href="#1-读写基本数据类型" class="headerlink" title="1,读写基本数据类型"></a>1,读写基本数据类型</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">/**</span></div><div class="line">    * 存储基本数据类型</div><div class="line">    * <span class="doctag">@param</span> context </div><div class="line">    * <span class="doctag">@param</span> key key</div><div class="line">    * <span class="doctag">@param</span> data value</div><div class="line">    */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">(Context context, String key, Object data)</span> </span>&#123;</div><div class="line">       String type = data.getClass().getSimpleName();</div><div class="line">       SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context</div><div class="line">               .MODE_PRIVATE);<span class="comment">//读写基本数据类型都是在一个特定的文件，以软件的包名为文件名</span></div><div class="line">       Editor editor = sharedPreferences.edit();</div><div class="line">       <span class="keyword">if</span> (<span class="string">"Integer"</span>.equals(type)) &#123;<span class="comment">//注意这里是integer对象，同下</span></div><div class="line">           editor.putInt(key, (Integer) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Boolean"</span>.equals(type)) &#123;</div><div class="line">           editor.putBoolean(key, (Boolean) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"String"</span>.equals(type)) &#123;</div><div class="line">           editor.putString(key, (String) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Float"</span>.equals(type)) &#123;</div><div class="line">           editor.putFloat(key, (Float) data);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Long"</span>.equals(type)) &#123;</div><div class="line">           editor.putLong(key, (Long) data);</div><div class="line">       &#125;</div><div class="line">       editor.commit();</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 读取基本数据类型</div><div class="line">    * <span class="doctag">@param</span> context</div><div class="line">    * <span class="doctag">@param</span> key key</div><div class="line">    * <span class="doctag">@param</span> defValue 当取不到值时返回默认值</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getData</span><span class="params">(Context context, String key, Object defValue)</span> </span>&#123;</div><div class="line">       String type = defValue.getClass().getSimpleName();</div><div class="line">       SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context</div><div class="line">               .MODE_PRIVATE);  <span class="comment">//defValue为为默认值，如果当前获取不到数据就返回它 </span></div><div class="line">       <span class="keyword">if</span> (<span class="string">"Integer"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getInt(key, (Integer) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Boolean"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getBoolean(key, (Boolean) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"String"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getString(key, (String) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Float"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getFloat(key, (Float) defValue);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Long"</span>.equals(type)) &#123;</div><div class="line">           <span class="keyword">return</span> sharedPreferences.getLong(key, (Long) defValue);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><p>将常用到的基本数据类型存入特定的文件中，获取的时候也十分方便快捷。（PS，string不是基本数据类型）</p>
<h2 id="读写Javabean类型"><a href="#读写Javabean类型" class="headerlink" title="读写Javabean类型"></a>读写Javabean类型</h2><p>先期准备<br>Javabean是序列化的，需要继承Serializable接口，实现serialVersionUID。<br>1.判断处理是否是各个数据类型</p>
<pre><code> private static boolean isObject(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; !isSingle(clazz) &amp;&amp; !isArray(clazz) &amp;&amp; !isCollection(clazz) &amp;&amp; !isMap(clazz);
}

private static boolean isSingle(Class&lt;?&gt; clazz) {
    return isBoolean(clazz) || isNumber(clazz) || isString(clazz);
}

public static boolean isBoolean(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (Boolean.TYPE.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz));
}

public static boolean isNumber(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (Byte.TYPE.isAssignableFrom(clazz) || Short.TYPE.isAssignableFrom(clazz) || Integer.TYPE.isAssignableFrom(clazz) || Long.TYPE.isAssignableFrom(clazz) || Float.TYPE.isAssignableFrom(clazz) || Double.TYPE.isAssignableFrom(clazz) || Number.class.isAssignableFrom(clazz));
}

public static boolean isString(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; (String.class.isAssignableFrom(clazz) || Character.TYPE.isAssignableFrom(clazz) || Character.class.isAssignableFrom(clazz));
}

public static boolean isArray(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; clazz.isArray();
}

public static boolean isCollection(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; Collection.class.isAssignableFrom(clazz);
}

public static boolean isMap(Class&lt;?&gt; clazz) {
    return clazz != null &amp;&amp; Map.class.isAssignableFrom(clazz);
}
private static boolean isParcelableCreator(Field field) {
    return Modifier.toString(field.getModifiers()).equals(&quot;public static final&quot;) &amp;&amp; &quot;CREATOR&quot;
            .equals(field.getName());
}
</code></pre><p>2,插入数据</p>
<pre><code> public static void setObject(Context context, Object o) {
    Field[] fields = o.getClass().getDeclaredFields();//获取所有声明的属性
    SharedPreferences sp = context.getSharedPreferences(o.getClass().getName(), 0);//将存储的文件名改为Javabean的包名+類名
    SharedPreferences.Editor editor = sp.edit();

    for (int i = 0; i &lt; fields.length; ++i) {
        if (!isParcelableCreator(fields[i])) {
            Class type = fields[i].getType();//类型 class java.lang.class
            String name = fields[i].getName();//名称 id
            Object e;
            if (isSingle(type)) {
                try {
                    if (type != Character.TYPE &amp;&amp; !type.equals(String.class)) {
                        if (!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)) {
                            if (type.equals(Double.TYPE)) {
                                editor.putLong(name, Double.doubleToLongBits(fields[i]
                                        .getDouble(o)));//将double类型的数值存入
                            } else if (type.equals(Float.TYPE)) {
                                editor.putFloat(name, fields[i].getFloat(o));//将float类型的数值存入
                            } else if (type.equals(Long.TYPE) &amp;&amp; !name.equals(&quot;serialVersionUID&quot;)) {
                                editor.putLong(name, fields[i].getLong(o));//将long类型的数值存入
                            } else if (type.equals(Boolean.TYPE)) {
                                editor.putBoolean(name, fields[i].getBoolean(o));//将boolean类型的数值存入
                            }
                        } else {
                            editor.putInt(name, fields[i].getInt(o));//将int类型的数值存入
                        }
                    } else {
                        e = fields[i].get(o);//将string类型的数值存入
                        editor.putString(name, null == e ? null : e.toString());
                    }
                } catch (Exception var14) {
                }
                }else if (isObject(type)) {
                    try {
                        e = fields[i].get(o);
                        if (null != e) {
                            setObject(context, e);
                        } else {
                            try {
                                setObject(context, fields[i].getClass().newInstance());//重新跑一遍
                            } catch (InstantiationException var11) {
                            }
                        }
                    } catch (Exception var12) {

                    }
                } else {
                try {
                    e = fields[i].get(o);
                    //转成json插入
                } catch (IllegalAccessException e1) {
                    e1.printStackTrace();
                }

            }
            }
        }
    editor.apply();
}

public static &lt;T&gt; T getObject(Context context, Class&lt;T&gt; clazz) {
    Object o = null;

    try {
        o = clazz.newInstance();
    } catch (InstantiationException e) {
        e.printStackTrace();
        return (T) o;
    } catch (IllegalAccessException e) {
        e.printStackTrace();
        return (T) o;
    }

    Field[] fields = clazz.getDeclaredFields();
    SharedPreferences sp = context.getSharedPreferences(clazz.getName(), 0);

    for(int i = 0; i &lt; fields.length; ++i) {
        if(!isParcelableCreator(fields[i])) {
            Class type = fields[i].getType();
            String name = fields[i].getName();
            String o_1;
            if(isSingle(type)) {
                try {
                    fields[i].setAccessible(true);
                    if(type != Character.TYPE &amp;&amp; !type.equals(String.class)) {
                        if(!type.equals(Integer.TYPE) &amp;&amp; !type.equals(Short.class)){
                            if(type.equals(Double.TYPE)) {
                                fields[i].setDouble(o, Double.longBitsToDouble(sp.getLong(name, 0L)));
                            } else if(type.equals(Float.TYPE)) {
                                fields[i].setFloat(o, sp.getFloat(name, 0.0F));
                            } else if(type.equals(Long.TYPE)) {
                                fields[i].setLong(o, sp.getLong(name, 0L));
                            } else if(type.equals(Boolean.TYPE)) {
                                fields[i].setBoolean(o, sp.getBoolean(name, false));
                            }
                        } else {
                            fields[i].setInt(o, sp.getInt(name, 0));
                        }
                    } else {
                        o_1 = sp.getString(name, (String)null);
                        if(null != o_1) {
                            fields[i].set(o, o_1);
                        }
                    }
                } catch (Exception e) {

                }
            } else if(isObject(type)) {
                Object tempValue = getObject(context, fields[i].getType());
                if(null != tempValue) {
                    fields[i].setAccessible(true);

                    try {
                        fields[i].set(o, tempValue);
                    } catch (Exception e) {

                    } 
                }
            } else {
                //json数据解析
            }
        }
    }

    return (T) o;
}
</code></pre><p>主要的思想就是遍历javabean所有的属性对象，取出，按照类型一个个的存入XML文件中。<br>取出时也是同时转成了存入的形式，很方便利</p>
<h2 id="读写List-lt-Javabean-gt"><a href="#读写List-lt-Javabean-gt" class="headerlink" title="读写List&lt;Javabean&gt;"></a>读写List&lt;<em>Javabean</em>&gt;</h2><p>对于list&lt;<em>javabean</em>&gt;，不太适合用上面的方法，一般来说不太会存这种数据，数据量比较大。如果有这个需求，可以把list&lt;<em>javabean</em>&gt;转成json形式，然后存入xml文件中。关于Javabean数据转成json会在另一篇叙述。</p>
<h2 id="读写图片资源"><a href="#读写图片资源" class="headerlink" title="读写图片资源"></a>读写图片资源</h2><p>所谓的读写图片，个人感觉用处不大，先说一下思路。其实也很简单，就是通过base64将输出流转成string。<br>代码奉上：</p>
<pre><code> private void saveBitmapToSharedPreferences(Context context,String key,Bitmap bitmap){  
    //第一步:将Bitmap压缩至字节数组输出流ByteArrayOutputStream  
    ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();  
    bitmap.compress(CompressFormat.PNG, 80, byteArrayOutputStream);  
    //第二步:利用Base64将字节数组输出流中的数据转换成字符串String  
    byte[] byteArray=byteArrayOutputStream.toByteArray();  
    String imageString=new String(Base64.encodeToString(byteArray, Base64.DEFAULT));  
    //第三步:将String保持至SharedPreferences  
    SharedPreferences sharedPreferences=context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);  
    Editor editor=sharedPreferences.edit();  
    editor.putString(key, imageString);  
    editor.commit();  
}  

private Bitmap getBitmapFromSharedPreferences(Context context, String key, Object defValue){  
    SharedPreferences sharedPreferences=getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);  
    //第一步:取出字符串形式的Bitmap  
    String imageString=context.sharedPreferences.getString(key,defValue);  
    //第二步:利用Base64将字符串转换为ByteArrayInputStream  
    byte[] byteArray=Base64.decode(imageString, Base64.DEFAULT);  
    ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(byteArray);  
    //第三步:利用ByteArrayInputStream生成Bitmap  
    Bitmap bitmap=BitmapFactory.decodeStream(byteArrayInputStream);  
    return bitmap; 
}  
</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>简单叙述了下SharedPreferences的使用，毕竟作为Android中几个主要的存储数据的方式，熟练掌握还是 非常有必要的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SharedPreferences可以存储基本类型，在这里不多阐述。在这里主要介绍怎么存储对象。&lt;br&gt;在我学习优化Utils工具包的一些常见的工具类。&lt;br&gt;在百度上的一些关于SharedPreferences存储对象的方式的使用Base64转，或者转成json类型，存入SharedPreferences中，这样写显得很笨拙。并不符合我的需求。在此给一种新的方法（我也不确定，应该很早就有这样写的吧）。&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>EventBus翻译</title>
    <link href="http://yoursite.com/2017/07/16/eventBus/"/>
    <id>http://yoursite.com/2017/07/16/eventBus/</id>
    <published>2017-07-16T05:42:58.000Z</published>
    <updated>2017-07-16T10:31:49.708Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是RxBus的权威文章的翻译,<a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">原文</a>，也算是写Retrofit+RxJava学习的开端 ，在以后的博客中会陆续介绍这种框架使用的好处（可能不会连续发布）。<br>这篇文章有三个部分：</p>
<ul>
<li>1.事件总线快速入门</li>
<li>2.用RxJava实现事件总线</li>
<li>3.这种方法的离别思念</li>
</ul>
<p>“RxBus”将不会成为一个库。实现事件总线RxJava是如此容易以至于它不能作为一个独立的库。</p>
<h2 id="第1部分：什么是事件总线？"><a href="#第1部分：什么是事件总线？" class="headerlink" title="第1部分：什么是事件总线？"></a>第1部分：什么是事件总线？</h2><p>让我们来谈谈两个似乎相似的概念：观察者模式和发布 - 订阅模式。<br>观察者模式<br>这是一个发展模式，借助此，你的类或主对象（被称为可观察者）利用相关信息（事件）通知其他感兴趣的类或对象（称为观察者）。<br>发布 - 订阅模式<br>发布 - 订阅模式的目标和观察者模式的目标是完全一样的，即你想要一些其他的类来了解正在发生的某些事件。<br>尽管如此，观察者模式和发布 - 订阅模式之间存在一个重要的语义差别：发布 - 订阅模式的重点是外界“广播”的消息。观察者并不关注事件传给谁，而只关注事件是否已经传出。换句话说，观察者（发布者）并不关注谁是观察员（订阅者）。<br>为什么匿名？<br>它允许这个东西叫做“脱钩”，这是计算机编程具有良好的口碑。在设计中，你想尽可能的保持低耦合。<br>通常情况下，你会期望发布者对每个它需要通知的用户有直接的了解，所以当事件或消息已准备就绪时，它可以去通知他们每个人。但随着事件的总线的出现，发布者被解除该任务，并且这种独立性有所帮助，因为发布者和订阅者不必有建立两者之间相关性的逻辑代码。<br>换句话说“自觉低耦论”是你的代码在书写时就应该所思考的，这是程序员应该有的水平。<br>如何匿名？<br>在发布 - 订阅模式中一个很自然的问题是：你如何真正地实现发布者和订阅者之间的匿名？一个简单的方法是得到一个中间人，让那个中间人负责所有的通信。而事件总线就是这样的一个中间人。<br>事件总线就是这么简单。<br>常用于Android的使用的两个事件总线库是otto和EventBus。网上有大量的帖子解释如何在你的手机应用程序中实现它们。</p>
<h2 id="第2部分：用总线RxJava实现事件（？？是“在”还是“用”）"><a href="#第2部分：用总线RxJava实现事件（？？是“在”还是“用”）" class="headerlink" title="第2部分：用总线RxJava实现事件（？？是“在”还是“用”）"></a>第2部分：用总线RxJava实现事件（？？是“在”还是“用”）</h2><p>我已经将使用Android上RxJava的显示世界的例子粘贴在这个GitHub库上，所以我会坚持展示其完整的实现方式。下面是执行的部分代码：</p>
<pre><code>// this is the middleman object
public class RxBus {

private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create());
  public void send(Object o) {
        _bus.onNext(o);
  }

  public Observable&lt;Object&gt; toObserverable() {
    return _bus;
  }
}
</code></pre><p>你现在有一个事件总线可以使用了。<br>这是你如何将事件发布到总线：</p>
<pre><code>@OnClick(R.id.btn_demo_rxbus_tap)
public void onTapButtonClicked() {

_rxBus.send(new TapEvent());
}
</code></pre><p>这是你如何倾听来自其他片段/服务等。</p>
<pre><code>_rxBus.toObserverable()
.subscribe(new Action1&lt;Object&gt;() {
  @Override
  public void call(Object event) {

    if(event instanceof TapEvent) {
      _showTapText();

    }else if(event instanceof SomeOtherEvent) {
      _doSomethingElse();
    }
  }
});
</code></pre><p>在这个例子中，我们后从顶部片段（绿色部分）的事件，并从底部片段（蓝色部分）中（通过总线）收听。<br>在下面这个例子中，我们从顶部片段（绿色方）发布事件，并从底部片段（蓝色部分）收听（通过事件总线）。</p>
<h2 id="第3部分-离别的思念"><a href="#第3部分-离别的思念" class="headerlink" title="第3部分 - 离别的思念"></a>第3部分 - 离别的思念</h2><p>死亡事件</p>
<p>在一些情况下，知道是否有观察者监听当前总线是非常有用的。比如，如果你使用事件总线来处理你的GCM推送通知），如果应用程序是在前台 ，此时你不希望发送推送通知，这时，监听“死亡事件”是非常重要的。<br>例如，在不久前发布的婚礼派对，我们增加了“信息”到我们的应用程序。如果用户的应用程序开启（因而具有至少一个或更多的听众到总线），我们不会发送推送通知，但如果他们的应用程序在后台，那么我们发送推送通知，让他们知道聊天信息。当一个事件被发布到事件总线后，如果没有用户在听，会返回一个死亡事件。如果我们得到一个死亡事件，推送通知的将被发送出去。<br>你将怎样利用RxBus来实现呢？</p>
<p>事实上，这很容易。受试者有一个有用的方法hasObservers，这将准确的告诉我们实现方式。这被添加RxJava的1.x release 中，所以你必须要安装RxAndroid的最新版本才能看到这种方法（0.23.0）。<br>如果你只是想在Andr​​oid应用程序中使用事件总线，你可能最好使用otto（强烈推荐）或EventBus库 。Otto有一个由注解推动的干净的API，可能更为简单易用。</p>
<p>虽然这篇文章写得很好，翻译的不好，以下的博客将会介绍EventBus的一般使用和RXJava及RxBus的使用。<br><a href="http://blog.csdn.net/u012930328/article/details/51993346" target="_blank" rel="external">Csdn原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是RxBus的权威文章的翻译,&lt;a href=&quot;http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/&quot; target=&quot;_blank
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android新布局-ConstraintLayout详解</title>
    <link href="http://yoursite.com/2016/07/27/constranintlayout/"/>
    <id>http://yoursite.com/2016/07/27/constranintlayout/</id>
    <published>2016-07-27T11:18:02.000Z</published>
    <updated>2017-07-19T14:10:22.842Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://blog.csdn.net/u012930328/article/details/52048531" target="_blank" rel="external">原文地址</a><br><br>谷歌在2016年的IO大会上推出的一种新的布局方式—-ConstraintLayout，这局是一种约束型的布局方式。在设置和介绍上类似IOS的自动布局。</p>
</blockquote>
<p>先放上Google的官方解析地址：<a href="https://codelabs.developers.google.com/codelabs/constraint-layout/index.html%20%E5%8E%9F%E6%96%87" target="_blank" rel="external">点击链接</a> ，虽然这个地址我从来没进去过，现在另外附上一份这个官方Demo的Github地址，git： <a href="https://github.com/googlecodelabs/constraint-layout.git" target="_blank" rel="external">https://github.com/googlecodelabs/constraint-layout.git</a><br>如果在Android studio中不会使用github，还是去找找相关资料了，毕竟这部分技能应该算的上是程序员必备了。<br>那么，从下面开始详细介绍ConstraintLayout这个布局的使用。</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><h2 id="第一步，工欲善其事"><a href="#第一步，工欲善其事" class="headerlink" title="第一步，工欲善其事"></a>第一步，工欲善其事</h2><p>首先先装上Android studio的新版，不要求是最新版，但一定是要超过2.2的版本，截止本文结束前，当前版本是2.2preview6。如果打算升级，但现在是2.1.2等稳定版，则选择更新，<br><img src="http://img.blog.csdn.net/20160727160636698" alt="这里写图片描述"><br>选择Update dialog of your IDE settings.<br><img src="http://img.blog.csdn.net/20160727160912420" alt="这里写图片描述"><br>在这里选择DEV版本。<br>虽然肯定不会升级成功，下面直接附上下载地址（PS：官方网址，需要翻墙），<a href="https://dl.google.com/dl/android/studio/ide-zips/2.2.0.0/android-studio-ide-145.2878421-windows.zip" target="_blank" rel="external">官方下载地址</a>，如果由于种种原因无法翻墙的基友们请看此处，<a href="http://pan.baidu.com/s/1jIGuAkY%20%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD" target="_blank" rel="external">百度云下载</a>。</p>
<h2 id="第二步，必先利其器"><a href="#第二步，必先利其器" class="headerlink" title="第二步，必先利其器"></a>第二步，必先利其器</h2><p> 理所当前，使用新的布局方式首先应该导包，ConstraintLayout所在的文件是android.support.constraint.ConstraintLayout，而这个文件在（箭头所指）<br> <img src="http://img.blog.csdn.net/20160727163601160" alt="这里写图片描述"><br> 使用Library Dependency可以直接导入。不明白Maven，Gradle等配置的童鞋，建议去找一些资料看，毕竟这在以后的开发中还是挺重要的。<br> 到了这一步终于可以使用ConstraintLayout这种布局方式了。<br> 在实际操作前先说一下他的性质。<br> 先看ConstraintLayout作为一个ViewGroup的子类，而他并没有没有重载onDraw的方法，他的onLayout（）方法也非常简单，<br> <img src="http://img.blog.csdn.net/20160727165148207" alt="这里写图片描述"><br> 可以看出所以源码中，他内部的子view都是以相对关系存在的，所以只要计算出子view的坐标，就能推算出其他childview该放在布局哪个位置。所以在他的layout的过程也十分简单。<br> 对于他的OnMeasure（）方法，有兴趣的同学可以去看看。另外附上一张RelativeLayout的布局，同样继承于ViewGroup，在他的onLayout（）方法中，见下图：<br> <img src="http://img.blog.csdn.net/20160727170423197" alt="这里写图片描述"><br>可以差不多的看出ConstraintLayout与RelativeLayout对于子控件的排列方式差不多，可以将ConstraintLayout理解为RelativeLayout的升级版（我也不知道这个名称是否得当，欢迎斧正）。<br>可以将ConstraintLayout当做RelativaLayout的布局使用，以及对于子控件的摆放，各位童鞋都有一些印象了吧。<br>、</p>
<h2 id="2-约束性关系"><a href="#2-约束性关系" class="headerlink" title="2.约束性关系"></a>2.约束性关系</h2><p>在这个布局中，最为关键重要的就是约束性关系这个概念。<br>我的表达能力不是很好，童鞋们理解就好，不理解的话请参考关系数据库完整性约束（大概意思）。<br>约束性关系帮助你保持子控件与子控件对齐或者存在相互的关系. 你可以使用锚点来约定子控件之间存在何种对齐方式。如下图的ButtonA与ButtonB。我们从ButtonA的锚点指向ButtonB，并约束了96dp的间距，则此时移动ButtonB则会与ButtonA保持96dp的距离，而且在移动时的ButtonA也会移动。而操作ButtonA则是很随意，这就是约束性的关系，ButtonA约束了ButtonB的行为。<br><img src="http://img.blog.csdn.net/20160727173423772" alt="这里写图片描述"><br>下图是动态操作，表述上文所述的一些行为。<br><img src="http://img.blog.csdn.net/20160727181918120" alt="这里写图片描述"></p>
<p>下面介绍一下完整的整体的各个含义：<br><img src="http://img.blog.csdn.net/20160727180829069" alt="这里写图片描述"><br>其中四个角的位置可以将控件缩放的操作点，而在四个边上的圆圈是锚点，（PS：锚点是对应的，上下的锚点只能和上下行的锚点链接，不能和左右的锚点链接），中间的椭圆形式句柄（？），这个的作用是将水平方向的控件内部的字体水平对齐。<br>下图详见操作（有一些操作现在没有讲到，比如自动对齐，这个将会在下面讲）：<br><img src="http://img.blog.csdn.net/20160727182933532" alt="这里写图片描述"></p>
<h2 id="3-正文"><a href="#3-正文" class="headerlink" title="3.正文"></a>3.正文</h2><p>上面的内容只是ConstraintLayout布局的一些基础知识点，现在我们来正式的看ConstraintLayout的使用。</p>
<p>我们先把一张图片附在布局中，成像效果如下：<br><img src="http://img.blog.csdn.net/20160727183558035" alt="这里写图片描述"><br>一些初学者会以为右侧的波浪线是图片的黑白平衡，通道，色差之类的，但很抱歉，什么也不是，是Android studio的布局中加载图片的一种显示方式。就像Button控件中有一个句柄一样，图片并没有这个东西。<br>现在我们把眼光移向右上角，会发现出现了一个2字，<img src="http://img.blog.csdn.net/20160727184053441" alt="这里写图片描述">，打开这个2（这个是错误的个数）会发现里面报了若干个（2个）错误（警告），下面来给大家讲解一下这些都是什么含义。<br><img src="http://img.blog.csdn.net/20160727184349382" alt="这里写图片描述"><br>其中第一个是：此子控件缺少约束，否则按左上角（0,0）的位置进行判断子控件的位置，这个错误在Relativelayout布局非常常见，可以不必理会。<br>在这里比较关键的是第二个警告，此控件缺少contentDescription这个节点，而这个节点同样也是新增的内容，是Android新版新增添的功能-无障碍阅读的一种实现。<br>对于Android新增的无障碍阅读功能在系统设置-无障碍里面（由于国产ROM的百花齐放，这个功能自己摸索去），这个功能的主要作用是给一些视力障碍的群体正常的使用Android系统，在触摸某些设置的控件时会发出提示音（使用Google提供的Talk软件）。而这个的操作就是依靠contentDescription这个新属性。添加地点在：<br><img src="http://img.blog.csdn.net/20160727185621243" alt="这里写图片描述"><br>点开之后是选择value，在@string/XXX下面，启动无障碍模式，会播报在此处选择的文字。<br>现在又出现一个新的面板-Properties，是对新功能的补充，如果大家还是怀念原来的样式，则打开方式是：右上角的<img src="http://img.blog.csdn.net/20160727185952263" alt="这里写图片描述"> 左右箭头的符号，顿时就有爱了，还是原来的配方，还是原来的味道。</p>
<p><img src="http://img.blog.csdn.net/20160727190109359" alt="这里写图片描述"></p>
<p>好了，扯了这么多闲话，现在正是创建约束性的操作，在通过上面的学习，相信大家对这个约束性的关系和创建约束肯定很感兴趣。</p>
<hr>
<p> <strong>1. 手工创建约束性的操作</strong><br> 容我先创建两个可亲可爱的按钮（Button），点击A Button右侧的圆圈，右侧的圆圈会出现类似呼吸灯的状态，点住按钮会出现一个箭头，将箭头想右引导，如果成功A Button会移动到B Button的旁边，而且A Button的呼吸灯变成红色（？原谅我没看出来）。到这步就手工创建好了两者的约束，可以自由操作了。<br> 具体操作如下：<br> <img src="http://img.blog.csdn.net/20160727191059768" alt="这里写图片描述"> </p>
<p> 这是两个控件中的手工创建约束，下面是单个控件与上层布局的约束。<br>这种方式比较好的地方在于可以与左右上下限定所谓的位置，类型LinearLayout的百分比的方式，<br>在代码中的体现是： <img src="http://img.blog.csdn.net/20160727191702396" alt="这里写图片描述"><br>比较好的融合了RelativeLayout和LinearLayout的优点。（对于百分比布局，将会在以后的文章中有详述）</p>
<p> <img src="http://img.blog.csdn.net/20160727191400658" alt="这里写图片描述"></p>
<p> 下面来说一下两个控件之间的基准约束条件。<br>将鼠标放置到Button A句柄处，当句柄开始变色（？）时用鼠标引导句柄，此时会从句柄处引申一条连接线，将此连接线连接到Button B 的句柄处，会发现Button A会移动到与Button B平齐（文字）的地方。（请注意右上角的警告数字，按照个人需求设置）。<br>在代码中的体现是在<img src="http://img.blog.csdn.net/20160728115622758" alt="这里写图片描述"><br>下图是如何设置的动态图<br> <img src="http://img.blog.csdn.net/20160728115110787" alt="这里写图片描述"></p>
<p>好了，个人的设置大约就是这样，下面开始介绍Properties面板的若干参数的含义。</p>
<p><img src="http://img.blog.csdn.net/20160728132014603" alt="这里写图片描述"><br>这个ImageView与上层布局的约束的状态。<br>想必各位看官们已经注意到了图中的16,50,39等数字，下面来给大家讲解一下各个数字的用处。16是当ImageView与上层布局出现约束关系时，四周与上层布局的间隔，也就是margin属性。用法一致，并没有发生改变。而50,39指的是50%和39%，相信大家看完下面的演示就会一目了然。<br><img src="http://img.blog.csdn.net/20160728133013165" alt="这里写图片描述"><br>移动这个百分比比率会影响控件在布局中的位置（演示的有点小卡），这些百分比率就是在布局中的比率的显示。<br>在这张图中，还有一些代表意义。<br>1.在上图中有<img src="http://img.blog.csdn.net/20160728133351934" alt="这里写图片描述">，wrap_content，这个的含义，在新式布局中，<br>对应的是<img src="http://img.blog.csdn.net/20160728133614532" alt="这里写图片描述"><br>对于wrap_content,在此就不做赘述，不知道或不明白的去面壁吧。<br>2.<img src="http://img.blog.csdn.net/20160728133907163" alt="这里写图片描述">，Fixed，对于这种样式，在布局中的代表含义是实际的距离，也就是我们给这个控件赋予的尺寸（指定的尺寸）。<br><img src="http://img.blog.csdn.net/20160728134034835" alt="这里写图片描述"><br>3.<img src="http://img.blog.csdn.net/20160728134151852" alt="这里写图片描述">，AnySize，对于这种样式，让子控件占用尽可能大的所有可用空间以去适应上层布局.<br><img src="http://img.blog.csdn.net/20160728134400353" alt="这里写图片描述"><br>看到在代码中的释义是不是很熟悉，又见0dp。</p>
<hr>
<p> <strong>2. 自动创建约束</strong><br> 下面来看布局上面面板的内容，有经验的同学可以很快发现这个面板和以往的有所不同。<br> <img src="http://img.blog.csdn.net/20160728134921152" alt="这里写图片描述"><br>多了下面这一排的图标，这次我们会仔细讲解一下这些图标的作用。<br>现在我们将按照逻辑来讲一下各个图标。<br>1.<img src="http://img.blog.csdn.net/20160728135403180" alt="这里写图片描述"><br>这个图标是左起第二个。作用是系统自动预测人类预期的行为而创建的约束—-简称自动创建约束（官方怎么称呼的我也不清楚）。<br>下面展示一下自动创建的流程。<br><img src="http://img.blog.csdn.net/20160729104939688" alt="这里写图片描述"><br>开启磁铁符号，将控件放置在布局中，可以清晰的看到约束的关系在自动的创建。<br>在新式布局中还有一种自动创建约束的按钮，左起第四个，<img src="http://img.blog.csdn.net/20160729105916226" alt="这里写图片描述">，点击这个按钮系统会提示控件与控件，控件与布局之间的可能存在的约束关系。<br>详情见下面的动图：<br><img src="http://img.blog.csdn.net/20160729123854137" alt="这里写图片描述"></p>
<p>这种自动约束的好处是免除自己去创建约束，但不好的地方在于约束太多，可能有很多约束不需要，而我们怎么删除这些约束呢？<br>下面我们来看第三个按钮，<img src="http://img.blog.csdn.net/20160729130758739" alt="这里写图片描述">，使用这个按钮就可以将所有的约束去除。如果不打算去除所有约束，而是不想将其显示出来，则使用第一个按钮，<img src="http://img.blog.csdn.net/20160729132501623" alt="这里写图片描述">，则可以将所有的约束关系显示/隐藏。（不贴图了，感兴趣的小伙伴们可以自己试试）<br>对于下面几个按钮，大家可以试试，是对控件进行操作。<br><img src="http://img.blog.csdn.net/20160729132727105" alt="这里写图片描述"></p>
<p>比如：<img src="http://img.blog.csdn.net/20160729132825965" alt="这里写图片描述"><br>是将控件的大小放置为可以容纳上层布局的最大的空间。</p>
<hr>
<hr>
<p>ConstraintLayout布局大约就是这些功能，现在看一下用这个布局做的一个简单的例子（丑，希望不要因为她丑而放弃他）。</p>
<p><img src="http://img.blog.csdn.net/20160729133934018" alt="这里写图片描述"></p>
<hr>
<p>在这里感谢！<a href="http://blog.csdn.net/jdsjlzx/article/details/51460581" target="_blank" rel="external">一叶飘舟</a> 大神博客的帮助，带我走进ConstraintLayout布局的大门。感谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u012930328/article/details/52048531&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&lt;br&gt;谷歌在2016年的I
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
